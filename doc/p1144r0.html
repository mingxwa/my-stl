<!doctype html><html lang="en">
 <head>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport">
  <title>P1144R0: Object relocation in terms of move plus destroy</title>
<style data-fill-with="stylesheet">/******************************************************************************
 *                   Style sheet for the W3C specifications                   *
 *
 * Special classes handled by this style sheet include:
 *
 * Indices
 *   - .toc for the Table of Contents (<ol class="toc">)
 *     + <span class="secno"> for the section numbers
 *   - #toc for the Table of Contents (<nav id="toc">)
 *   - ul.index for Indices (<a href="#ref">term</a><span>, in §N.M</span>)
 *   - table.index for Index Tables (e.g. for properties or elements)
 *
 * Structural Markup
 *   - table.data for general data tables
 *     -> use 'scope' attribute, <colgroup>, <thead>, and <tbody> for best results !
 *     -> use <table class='complex data'> for extra-complex tables
 *     -> use <td class='long'> for paragraph-length cell content
 *     -> use <td class='pre'> when manual line breaks/indentation would help readability
 *   - dl.switch for switch statements
 *   - ol.algorithm for algorithms (helps to visualize nesting)
 *   - .figure and .caption (HTML4) and figure and figcaption (HTML5)
 *     -> .sidefigure for right-floated figures
 *   - ins/del
 *
 * Code
 *   - pre and code
 *
 * Special Sections
 *   - .note       for informative notes             (div, p, span, aside, details)
 *   - .example    for informative examples          (div, p, pre, span)
 *   - .issue      for issues                        (div, p, span)
 *   - .assertion  for assertions                    (div, p, span)
 *   - .advisement for loud normative statements     (div, p, strong)
 *   - .annoying-warning for spec obsoletion notices (div, aside, details)
 *
 * Definition Boxes
 *   - pre.def   for WebIDL definitions
 *   - table.def for tables that define other entities (e.g. CSS properties)
 *   - dl.def    for definition lists that define other entitles (e.g. HTML elements)
 *
 * Numbering
 *   - .secno for section numbers in .toc and headings (<span class='secno'>3.2</span>)
 *   - .marker for source-inserted example/figure/issue numbers (<span class='marker'>Issue 4</span>)
 *   - ::before styled for CSS-generated issue/example/figure numbers:
 *     -> Documents wishing to use this only need to add
 *        figcaption::before,
 *        .caption::before { content: "Figure "  counter(figure) " ";  }
 *        .example::before { content: "Example " counter(example) " "; }
 *        .issue::before   { content: "Issue "   counter(issue) " ";   }
 *
 * Header Stuff (ignore, just don't conflict with these classes)
 *   - .head for the header
 *   - .copyright for the copyright
 *
 * Miscellaneous
 *   - .overlarge for things that should be as wide as possible, even if
 *     that overflows the body text area. This can be used on an item or
 *     on its container, depending on the effect desired.
 *     Note that this styling basically doesn't help at all when printing,
 *     since A4 paper isn't much wider than the max-width here.
 *     It's better to design things to fit into a narrower measure if possible.
 *   - js-added ToC jump links (see fixup.js)
 *
 ******************************************************************************/

/******************************************************************************/
/*                                   Body                                     */
/******************************************************************************/

	body {
		counter-reset: example figure issue;

		/* Layout */
		max-width: 50em;               /* limit line length to 50em for readability   */
		margin: 0 auto;                /* center text within page                     */
		padding: 1.6em 1.5em 2em 50px; /* assume 16px font size for downlevel clients */
		padding: 1.6em 1.5em 2em calc(26px + 1.5em); /* leave space for status flag     */

		/* Typography */
		line-height: 1.5;
		font-family: sans-serif;
		widows: 2;
		orphans: 2;
		word-wrap: break-word;
		overflow-wrap: break-word;
		hyphens: auto;

		/* Colors */
		color: black;
		background: white top left fixed no-repeat;
		background-size: 25px auto;
	}


/******************************************************************************/
/*                         Front Matter & Navigation                          */
/******************************************************************************/

/** Header ********************************************************************/

	div.head { margin-bottom: 1em }
	div.head hr { border-style: solid; }

	div.head h1 {
		font-weight: bold;
		margin: 0 0 .1em;
		font-size: 220%;
	}

	div.head h2 { margin-bottom: 1.5em;}

/** W3C Logo ******************************************************************/

	.head .logo {
		float: right;
		margin: 0.4rem 0 0.2rem .4rem;
	}

	.head img[src*="logos/W3C"] {
		display: block;
		border: solid #1a5e9a;
		border-width: .65rem .7rem .6rem;
		border-radius: .4rem;
		background: #1a5e9a;
		color: white;
		font-weight: bold;
	}

	.head a:hover > img[src*="logos/W3C"],
	.head a:focus > img[src*="logos/W3C"] {
		opacity: .8;
	}

	.head a:active > img[src*="logos/W3C"] {
		background: #c00;
		border-color: #c00;
	}

	/* see also additional rules in Link Styling section */

/** Copyright *****************************************************************/

	p.copyright,
	p.copyright small { font-size: small }

/** Back to Top / ToC Toggle **************************************************/

	@media print {
		#toc-nav {
			display: none;
		}
	}
	@media not print {
		#toc-nav {
			position: fixed;
			z-index: 2;
			bottom: 0; left: 0;
			margin: 0;
			min-width: 1.33em;
			border-top-right-radius: 2rem;
			box-shadow: 0 0 2px;
			font-size: 1.5em;
			color: black;
		}
		#toc-nav > a {
			display: block;
			white-space: nowrap;

			height: 1.33em;
			padding: .1em 0.3em;
			margin: 0;

			background: white;
			box-shadow: 0 0 2px;
			border: none;
			border-top-right-radius: 1.33em;
			background: white;
		}
		#toc-nav > #toc-jump {
			padding-bottom: 2em;
			margin-bottom: -1.9em;
		}

		#toc-nav > a:hover,
		#toc-nav > a:focus {
			background: #f8f8f8;
		}
		#toc-nav > a:not(:hover):not(:focus) {
			color: #707070;
		}

		/* statusbar gets in the way on keyboard focus; remove once browsers fix */
		#toc-nav > a[href="#toc"]:not(:hover):focus:last-child {
			padding-bottom: 1.5rem;
		}

		#toc-nav:not(:hover) > a:not(:focus) > span + span {
			/* Ideally this uses :focus-within on #toc-nav */
			display: none;
		}
		#toc-nav > a > span + span {
			padding-right: 0.2em;
		}

		#toc-toggle-inline {
			vertical-align: 0.05em;
			font-size: 80%;
			color: gray;
			color: hsla(203,20%,40%,.7);
			border-style: none;
			background: transparent;
			position: relative;
		}
		#toc-toggle-inline:hover:not(:active),
		#toc-toggle-inline:focus:not(:active) {
			text-shadow: 1px 1px silver;
			top: -1px;
			left: -1px;
		}

		#toc-nav :active {
			color: #C00;
		}
	}

/** ToC Sidebar ***************************************************************/

	/* Floating sidebar */
	@media screen {
		body.toc-sidebar #toc {
			position: fixed;
			top: 0; bottom: 0;
			left: 0;
			width: 23.5em;
			max-width: 80%;
			max-width: calc(100% - 2em - 26px);
			overflow: auto;
			padding: 0 1em;
			padding-left: 42px;
			padding-left: calc(1em + 26px);
			background: inherit;
			background-color: #f7f8f9;
			z-index: 1;
			box-shadow: -.1em 0 .25em rgba(0,0,0,.1) inset;
		}
		body.toc-sidebar #toc h2 {
			margin-top: .8rem;
			font-variant: small-caps;
			font-variant: all-small-caps;
			text-transform: lowercase;
			font-weight: bold;
			color: gray;
			color: hsla(203,20%,40%,.7);
		}
		body.toc-sidebar #toc-jump:not(:focus) {
			width: 0;
			height: 0;
			padding: 0;
			position: absolute;
			overflow: hidden;
		}
	}
	/* Hide main scroller when only the ToC is visible anyway */
	@media screen and (max-width: 28em) {
		body.toc-sidebar {
			overflow: hidden;
		}
	}

	/* Sidebar with its own space */
	@media screen and (min-width: 78em) {
		body:not(.toc-inline) #toc {
			position: fixed;
			top: 0; bottom: 0;
			left: 0;
			width: 23.5em;
			overflow: auto;
			padding: 0 1em;
			padding-left: 42px;
			padding-left: calc(1em + 26px);
			background: inherit;
			background-color: #f7f8f9;
			z-index: 1;
			box-shadow: -.1em 0 .25em rgba(0,0,0,.1) inset;
		}
		body:not(.toc-inline) #toc h2 {
			margin-top: .8rem;
			font-variant: small-caps;
			font-variant: all-small-caps;
			text-transform: lowercase;
			font-weight: bold;
			color: gray;
			color: hsla(203,20%,40%,.7);
		}

		body:not(.toc-inline) {
			padding-left: 29em;
		}
		/* See also Overflow section at the bottom */

		body:not(.toc-inline) #toc-jump:not(:focus) {
			width: 0;
			height: 0;
			padding: 0;
			position: absolute;
			overflow: hidden;
		}
	}
	@media screen and (min-width: 90em) {
		body:not(.toc-inline) {
			margin: 0 4em;
		}
	}

/******************************************************************************/
/*                                Sectioning                                  */
/******************************************************************************/

/** Headings ******************************************************************/

	h1, h2, h3, h4, h5, h6, dt {
		page-break-after: avoid;
		page-break-inside: avoid;
		font: 100% sans-serif;   /* Reset all font styling to clear out UA styles */
		font-family: inherit;    /* Inherit the font family. */
		line-height: 1.2;        /* Keep wrapped headings compact */
		hyphens: manual;         /* Hyphenated headings look weird */
	}

	h2, h3, h4, h5, h6 {
		margin-top: 3rem;
	}

	h1, h2, h3 {
		color: #005A9C;
		background: transparent;
	}

	h1 { font-size: 170%; }
	h2 { font-size: 140%; }
	h3 { font-size: 120%; }
	h4 { font-weight: bold; }
	h5 { font-style: italic; }
	h6 { font-variant: small-caps; }
	dt { font-weight: bold; }

/** Subheadings ***************************************************************/

	h1 + h2,
	#subtitle {
		/* #subtitle is a subtitle in an H2 under the H1 */
		margin-top: 0;
	}
	h2 + h3,
	h3 + h4,
	h4 + h5,
	h5 + h6 {
		margin-top: 1.2em; /* = 1 x line-height */
	}

/** Section divider ***********************************************************/

	:not(.head) > hr {
		font-size: 1.5em;
		text-align: center;
		margin: 1em auto;
		height: auto;
		border: transparent solid 0;
		background: transparent;
	}
	:not(.head) > hr::before {
		content: "\2727\2003\2003\2727\2003\2003\2727";
	}

/******************************************************************************/
/*                            Paragraphs and Lists                            */
/******************************************************************************/

	p {
		margin: 1em 0;
	}

	dd > p:first-child,
	li > p:first-child {
		margin-top: 0;
	}

	ul, ol {
		margin-left: 0;
		padding-left: 2em;
	}

	li {
		margin: 0.25em 0 0.5em;
		padding: 0;
	}

	dl dd {
		margin: 0 0 .5em 2em;
	}

	.head dd + dd { /* compact for header */
		margin-top: -.5em;
	}

	/* Style for algorithms */
	ol.algorithm ol:not(.algorithm),
	.algorithm > ol ol:not(.algorithm) {
	 border-left: 0.5em solid #DEF;
	}

	/* Put nice boxes around each algorithm. */
	[data-algorithm]:not(.heading) {
	  padding: .5em;
	  border: thin solid #ddd; border-radius: .5em;
	  margin: .5em calc(-0.5em - 1px);
	}
	[data-algorithm]:not(.heading) > :first-child {
	  margin-top: 0;
	}
	[data-algorithm]:not(.heading) > :last-child {
	  margin-bottom: 0;
	}

	/* Style for switch/case <dl>s */
	dl.switch > dd > ol.only,
	dl.switch > dd > .only > ol {
	 margin-left: 0;
	}
	dl.switch > dd > ol.algorithm,
	dl.switch > dd > .algorithm > ol {
	 margin-left: -2em;
	}
	dl.switch {
	 padding-left: 2em;
	}
	dl.switch > dt {
	 text-indent: -1.5em;
	 margin-top: 1em;
	}
	dl.switch > dt + dt {
	 margin-top: 0;
	}
	dl.switch > dt::before {
	 content: '\21AA';
	 padding: 0 0.5em 0 0;
	 display: inline-block;
	 width: 1em;
	 text-align: right;
	 line-height: 0.5em;
	}

/** Terminology Markup ********************************************************/


/******************************************************************************/
/*                                 Inline Markup                              */
/******************************************************************************/

/** Terminology Markup ********************************************************/
	dfn   { /* Defining instance */
		font-weight: bolder;
	}
	a > i { /* Instance of term */
		font-style: normal;
	}
	dt dfn code, code.idl {
		font-size: medium;
	}
	dfn var {
		font-style: normal;
	}

/** Change Marking ************************************************************/

	del { color: red;  text-decoration: line-through; }
	ins { color: #080; text-decoration: underline;    }

/** Miscellaneous improvements to inline formatting ***************************/

	sup {
		vertical-align: super;
		font-size: 80%
	}

/******************************************************************************/
/*                                    Code                                    */
/******************************************************************************/

/** General monospace/pre rules ***********************************************/

	pre, code, samp {
		font-family: Menlo, Consolas, "DejaVu Sans Mono", Monaco, monospace;
		font-size: .9em;
		page-break-inside: avoid;
		hyphens: none;
		text-transform: none;
	}
	pre code,
	code code {
		font-size: 100%;
	}

	pre {
		margin-top: 1em;
		margin-bottom: 1em;
		overflow: auto;
	}

/** Inline Code fragments *****************************************************/

  /* Do something nice. */

/******************************************************************************/
/*                                    Links                                   */
/******************************************************************************/

/** General Hyperlinks ********************************************************/

	/* We hyperlink a lot, so make it less intrusive */
	a[href] {
		color: #034575;
		text-decoration: none;
		border-bottom: 1px solid #707070;
		/* Need a bit of extending for it to look okay */
		padding: 0 1px 0;
		margin: 0 -1px 0;
	}
	a:visited {
		border-bottom-color: #BBB;
	}

	/* Use distinguishing colors when user is interacting with the link */
	a[href]:focus,
	a[href]:hover {
		background: #f8f8f8;
		background: rgba(75%, 75%, 75%, .25);
		border-bottom-width: 3px;
		margin-bottom: -2px;
	}
	a[href]:active {
		color: #C00;
		border-color: #C00;
	}

	/* Backout above styling for W3C logo */
	.head .logo,
	.head .logo a {
		border: none;
		text-decoration: none;
		background: transparent;
	}

/******************************************************************************/
/*                                    Images                                  */
/******************************************************************************/

	img {
		border-style: none;
	}

	/* For autogen numbers, add
	   .caption::before, figcaption::before { content: "Figure " counter(figure) ". "; }
	*/

	figure, .figure, .sidefigure {
		page-break-inside: avoid;
		text-align: center;
		margin: 2.5em 0;
	}
	.figure img,    .sidefigure img,    figure img,
	.figure object, .sidefigure object, figure object {
		max-width: 100%;
		margin: auto;
	}
	.figure pre, .sidefigure pre, figure pre {
		text-align: left;
		display: table;
		margin: 1em auto;
	}
	.figure table, figure table {
		margin: auto;
	}
	@media screen and (min-width: 20em) {
		.sidefigure {
			float: right;
			width: 50%;
			margin: 0 0 0.5em 0.5em
		}
	}
	.caption, figcaption, caption {
		font-style: italic;
		font-size: 90%;
	}
	.caption::before, figcaption::before, figcaption > .marker {
		font-weight: bold;
	}
	.caption, figcaption {
		counter-increment: figure;
	}

	/* DL list is indented 2em, but figure inside it is not */
	dd > .figure, dd > figure { margin-left: -2em }

/******************************************************************************/
/*                             Colored Boxes                                  */
/******************************************************************************/

	.issue, .note, .example, .assertion, .advisement, blockquote {
		padding: .5em;
		border: .5em;
		border-left-style: solid;
		page-break-inside: avoid;
	}
	span.issue, span.note {
		padding: .1em .5em .15em;
		border-right-style: solid;
	}

	.issue,
	.note,
	.example,
	.advisement,
	.assertion,
	blockquote {
		margin: 1em auto;
	}
	.note  > p:first-child,
	.issue > p:first-child,
	blockquote > :first-child {
		margin-top: 0;
	}
	blockquote > :last-child {
		margin-bottom: 0;
	}

/** Blockquotes ***************************************************************/

	blockquote {
		border-color: silver;
	}

/** Open issue ****************************************************************/

	.issue {
		border-color: #E05252;
		background: #FBE9E9;
		counter-increment: issue;
		overflow: auto;
	}
	.issue::before, .issue > .marker {
		text-transform: uppercase;
		color: #AE1E1E;
		padding-right: 1em;
		text-transform: uppercase;
	}
	/* Add .issue::before { content: "Issue " counter(issue) " "; } for autogen numbers,
	   or use class="marker" to mark up the issue number in source. */

/** Example *******************************************************************/

	.example {
		border-color: #E0CB52;
		background: #FCFAEE;
		counter-increment: example;
		overflow: auto;
		clear: both;
	}
	.example::before, .example > .marker {
		text-transform: uppercase;
		color: #827017;
		min-width: 7.5em;
		display: block;
	}
	/* Add .example::before { content: "Example " counter(example) " "; } for autogen numbers,
	   or use class="marker" to mark up the example number in source. */

/** Non-normative Note ********************************************************/

	.note {
		border-color: #52E052;
		background: #E9FBE9;
		overflow: auto;
	}

	.note::before, .note > .marker,
	details.note > summary::before,
	details.note > summary > .marker {
		text-transform: uppercase;
		display: block;
		color: hsl(120, 70%, 30%);
	}
	/* Add .note::before { content: "Note"; } for autogen label,
	   or use class="marker" to mark up the label in source. */

	details.note > summary {
		display: block;
		color: hsl(120, 70%, 30%);
	}
	details.note[open] > summary {
		border-bottom: 1px silver solid;
	}

/** Assertion Box *************************************************************/
	/*  for assertions in algorithms */

	.assertion {
		border-color: #AAA;
		background: #EEE;
	}

/** Advisement Box ************************************************************/
	/*  for attention-grabbing normative statements */

	.advisement {
		border-color: orange;
		border-style: none solid;
		background: #FFEECC;
	}
	strong.advisement {
		display: block;
		text-align: center;
	}
	.advisement > .marker {
		color: #B35F00;
	}

/** Spec Obsoletion Notice ****************************************************/
	/* obnoxious obsoletion notice for older/abandoned specs. */

	details {
		display: block;
	}
	summary {
		font-weight: bolder;
	}

	.annoying-warning:not(details),
	details.annoying-warning:not([open]) > summary,
	details.annoying-warning[open] {
		background: #fdd;
		color: red;
		font-weight: bold;
		padding: .75em 1em;
		border: thick red;
		border-style: solid;
		border-radius: 1em;
	}
	.annoying-warning :last-child {
		margin-bottom: 0;
	}

@media not print {
	details.annoying-warning[open] {
		position: fixed;
		left: 1em;
		right: 1em;
		bottom: 1em;
		z-index: 1000;
	}
}

	details.annoying-warning:not([open]) > summary {
		text-align: center;
	}

/** Entity Definition Boxes ***************************************************/

	.def {
		padding: .5em 1em;
		background: #DEF;
		margin: 1.2em 0;
		border-left: 0.5em solid #8CCBF2;
	}

/******************************************************************************/
/*                                    Tables                                  */
/******************************************************************************/

	th, td {
		text-align: left;
		text-align: start;
	}

/** Property/Descriptor Definition Tables *************************************/

	table.def {
		/* inherits .def box styling, see above */
		width: 100%;
		border-spacing: 0;
	}

	table.def td,
	table.def th {
		padding: 0.5em;
		vertical-align: baseline;
		border-bottom: 1px solid #bbd7e9;
	}

	table.def > tbody > tr:last-child th,
	table.def > tbody > tr:last-child td {
		border-bottom: 0;
	}

	table.def th {
		font-style: italic;
		font-weight: normal;
		padding-left: 1em;
		width: 3em;
	}

	/* For when values are extra-complex and need formatting for readability */
	table td.pre {
		white-space: pre-wrap;
	}

	/* A footnote at the bottom of a def table */
	table.def           td.footnote {
		padding-top: 0.6em;
	}
	table.def           td.footnote::before {
		content: " ";
		display: block;
		height: 0.6em;
		width: 4em;
		border-top: thin solid;
	}

/** Data tables (and properly marked-up index tables) *************************/
	/*
		 <table class="data"> highlights structural relationships in a table
		 when correct markup is used (e.g. thead/tbody, th vs. td, scope attribute)

		 Use class="complex data" for particularly complicated tables --
		 (This will draw more lines: busier, but clearer.)

		 Use class="long" on table cells with paragraph-like contents
		 (This will adjust text alignment accordingly.)
		 Alternately use class="longlastcol" on tables, to have the last column assume "long".
	*/

	table {
		word-wrap: normal;
		overflow-wrap: normal;
		hyphens: manual;
	}

	table.data,
	table.index {
		margin: 1em auto;
		border-collapse: collapse;
		border: hidden;
		width: 100%;
	}
	table.data caption,
	table.index caption {
		max-width: 50em;
		margin: 0 auto 1em;
	}

	table.data td,  table.data th,
	table.index td, table.index th {
		padding: 0.5em 1em;
		border-width: 1px;
		border-color: silver;
		border-top-style: solid;
	}

	table.data thead td:empty {
		padding: 0;
		border: 0;
	}

	table.data  thead,
	table.index thead,
	table.data  tbody,
	table.index tbody {
		border-bottom: 2px solid;
	}

	table.data colgroup,
	table.index colgroup {
		border-left: 2px solid;
	}

	table.data  tbody th:first-child,
	table.index tbody th:first-child  {
		border-right: 2px solid;
		border-top: 1px solid silver;
		padding-right: 1em;
	}

	table.data th[colspan],
	table.data td[colspan] {
		text-align: center;
	}

	table.complex.data th,
	table.complex.data td {
		border: 1px solid silver;
		text-align: center;
	}

	table.data.longlastcol td:last-child,
	table.data td.long {
	 vertical-align: baseline;
	 text-align: left;
	}

	table.data img {
		vertical-align: middle;
	}


/*
Alternate table alignment rules

	table.data,
	table.index {
		text-align: center;
	}

	table.data  thead th[scope="row"],
	table.index thead th[scope="row"] {
		text-align: right;
	}

	table.data  tbody th:first-child,
	table.index tbody th:first-child  {
		text-align: right;
	}

Possible extra rowspan handling

	table.data  tbody th[rowspan]:not([rowspan='1']),
	table.index tbody th[rowspan]:not([rowspan='1']),
	table.data  tbody td[rowspan]:not([rowspan='1']),
	table.index tbody td[rowspan]:not([rowspan='1']) {
		border-left: 1px solid silver;
	}

	table.data  tbody th[rowspan]:first-child,
	table.index tbody th[rowspan]:first-child,
	table.data  tbody td[rowspan]:first-child,
	table.index tbody td[rowspan]:first-child{
		border-left: 0;
		border-right: 1px solid silver;
	}
*/

/******************************************************************************/
/*                                  Indices                                   */
/******************************************************************************/


/** Table of Contents *********************************************************/

	.toc a {
		/* More spacing; use padding to make it part of the click target. */
		padding-top: 0.1rem;
		/* Larger, more consistently-sized click target */
		display: block;
		/* Reverse color scheme */
		color: black;
		border-color: #3980B5;
		border-bottom-width: 3px !important;
		margin-bottom: 0px !important;
	}
	.toc a:visited {
		border-color: #054572;
	}
	.toc a:not(:focus):not(:hover) {
		/* Allow colors to cascade through from link styling */
		border-bottom-color: transparent;
	}

	.toc, .toc ol, .toc ul, .toc li {
		list-style: none; /* Numbers must be inlined into source */
		/* because generated content isn't search/selectable and markers can't do multilevel yet */
		margin:  0;
		padding: 0;
		line-height: 1.1rem; /* consistent spacing */
	}

	/* ToC not indented until third level, but font style & margins show hierarchy */
	.toc > li             { font-weight: bold;   }
	.toc > li li          { font-weight: normal; }
	.toc > li li li       { font-size:   95%;    }
	.toc > li li li li    { font-size:   90%;    }
	.toc > li li li li .secno { font-size: 85%; }
	.toc > li li li li li { font-size:   85%;    }
	.toc > li li li li li .secno { font-size: 100%; }

	/* @supports not (display:grid) { */
		.toc > li             { margin: 1.5rem 0;    }
		.toc > li li          { margin: 0.3rem 0;    }
		.toc > li li li       { margin-left: 2rem;   }

		/* Section numbers in a column of their own */
		.toc .secno {
			float: left;
			width: 4rem;
			white-space: nowrap;
		}

		.toc li {
			clear: both;
		}

		:not(li) > .toc              { margin-left:  5rem; }
		.toc .secno                  { margin-left: -5rem; }
		.toc > li li li .secno       { margin-left: -7rem; }
		.toc > li li li li .secno    { margin-left: -9rem; }
		.toc > li li li li li .secno { margin-left: -11rem; }

		/* Tighten up indentation in narrow ToCs */
		@media (max-width: 30em) {
			:not(li) > .toc              { margin-left:  4rem; }
			.toc .secno                  { margin-left: -4rem; }
			.toc > li li li              { margin-left:  1rem; }
			.toc > li li li .secno       { margin-left: -5rem; }
			.toc > li li li li .secno    { margin-left: -6rem; }
			.toc > li li li li li .secno { margin-left: -7rem; }
		}
	/* } */

	@supports (display:grid) {
		/* Use #toc over .toc to override non-@supports rules. */
		#toc {
			display: grid;
			align-content: start;
			grid-template-columns: auto 1fr;
			grid-column-gap: 1rem;
			column-gap: 1rem;
			grid-row-gap: .6rem;
			row-gap: .6rem;
		}
		#toc h2 {
			grid-column: 1 / -1;
			margin-bottom: 0;
		}
		#toc ol,
		#toc li,
		#toc a {
			display: contents;
			/* Switch <a> to subgrid when supported */
		}
		#toc span {
			margin: 0;
		}
		#toc > .toc > li > a > span {
			/* The spans of the top-level list,
			   comprising the first items of each top-level section. */
			margin-top: 1.1rem;
		}
		#toc#toc .secno { /* Ugh, need more specificity to override base.css */
			grid-column: 1;
			width: auto;
			margin-left: 0;
		}
		#toc .content {
			grid-column: 2;
			width: auto;
			margin-right: 1rem;
		}
		#toc .content:hover {
			background: rgba(75%, 75%, 75%, .25);
			border-bottom: 3px solid #054572;
			margin-bottom: -3px;
		}
		#toc li li li .content {
			margin-left: 1rem;
		}
		#toc li li li li .content {
			margin-left: 2rem;
		}
	}


/** Index *********************************************************************/

	/* Index Lists: Layout */
	ul.index       { margin-left: 0; columns: 15em; text-indent: 1em hanging; }
	ul.index li    { margin-left: 0; list-style: none; break-inside: avoid; }
	ul.index li li { margin-left: 1em }
	ul.index dl    { margin-top: 0; }
	ul.index dt    { margin: .2em 0 .2em 20px;}
	ul.index dd    { margin: .2em 0 .2em 40px;}
	/* Index Lists: Typography */
	ul.index ul,
	ul.index dl { font-size: smaller; }
	@media not print {
		ul.index li span {
			white-space: nowrap;
			color: transparent; }
		ul.index li a:hover + span,
		ul.index li a:focus + span {
			color: #707070;
		}
	}

/** Index Tables *****************************************************/
	/* See also the data table styling section, which this effectively subclasses */

	table.index {
		font-size: small;
		border-collapse: collapse;
		border-spacing: 0;
		text-align: left;
		margin: 1em 0;
	}

	table.index td,
	table.index th {
		padding: 0.4em;
	}

	table.index tr:hover td:not([rowspan]),
	table.index tr:hover th:not([rowspan]) {
		background: #f7f8f9;
	}

	/* The link in the first column in the property table (formerly a TD) */
	table.index th:first-child a {
		font-weight: bold;
	}

/******************************************************************************/
/*                                    Print                                   */
/******************************************************************************/

	@media print {
		/* Pages have their own margins. */
		html {
			margin: 0;
		}
		/* Serif for print. */
		body {
			font-family: serif;
		}
	}
	@page {
		margin: 1.5cm 1.1cm;
	}

/******************************************************************************/
/*                                    Legacy                                  */
/******************************************************************************/

	/* This rule is inherited from past style sheets. No idea what it's for. */
	.hide { display: none }



/******************************************************************************/
/*                             Overflow Control                               */
/******************************************************************************/

	.figure .caption, .sidefigure .caption, figcaption {
		/* in case figure is overlarge, limit caption to 50em */
		max-width: 50rem;
		margin-left: auto;
		margin-right: auto;
	}
	.overlarge > table {
		/* limit preferred width of table */
		max-width: 50em;
		margin-left: auto;
		margin-right: auto;
	}

	@media (min-width: 55em) {
		.overlarge {
			margin-left: calc(13px + 26.5rem - 50vw);
			margin-right: calc(13px + 26.5rem - 50vw);
			max-width: none;
		}
	}
	@media screen and (min-width: 78em) {
		body:not(.toc-inline) .overlarge {
			/* 30.5em body padding 50em content area */
			margin-left: calc(40em - 50vw) !important;
			margin-right: calc(40em - 50vw) !important;
		}
	}
	@media screen and (min-width: 90em) {
		body:not(.toc-inline) .overlarge {
			/* 4em html margin 30.5em body padding 50em content area */
			margin-left: 0 !important;
			margin-right: calc(84.5em - 100vw) !important;
		}
	}

	@media not print {
		.overlarge {
			overflow-x: auto;
			/* See Lea Verou's explanation background-attachment:
			 * http://lea.verou.me/2012/04/background-attachment-local/
			 *
			background: top left  / 4em 100% linear-gradient(to right,  #ffffff, rgba(255, 255, 255, 0)) local,
			            top right / 4em 100% linear-gradient(to left, #ffffff, rgba(255, 255, 255, 0)) local,
			            top left  / 1em 100% linear-gradient(to right,  #c3c3c5, rgba(195, 195, 197, 0)) scroll,
			            top right / 1em 100% linear-gradient(to left, #c3c3c5, rgba(195, 195, 197, 0)) scroll,
			            white;
			background-repeat: no-repeat;
			*/
		}
	}
</style>
<style type="text/css">
    table, th, td {
      border: 1px solid black;
      border-collapse: collapse;
      vertical-align: top;
    }
    th, td {
      border-left: none;
      border-right: none;
      padding: 0px 10px;
    }
    th {
      text-align: center;
    }
  </style>
  <meta content="Bikeshed version dff342f4b23fb230b71436fb31b55f5f169715bd" name="generator">
  <link href="https://isocpp.org/favicon.ico" rel="icon">
<style>
ins  {background-color: #CCFFCC; text-decoration: underline;}
del  {background-color: #FFCACA; text-decoration: line-through;}
</style>
<style>/* style-md-lists */

/* This is a weird hack for me not yet following the commonmark spec
   regarding paragraph and lists. */
[data-md] > :first-child {
    margin-top: 0;
}
[data-md] > :last-child {
    margin-bottom: 0;
}</style>
<style>/* style-selflinks */

.heading, .issue, .note, .example, li, dt {
    position: relative;
}
a.self-link {
    position: absolute;
    top: 0;
    left: calc(-1 * (3.5rem - 26px));
    width: calc(3.5rem - 26px);
    height: 2em;
    text-align: center;
    border: none;
    transition: opacity .2s;
    opacity: .5;
}
a.self-link:hover {
    opacity: 1;
}
.heading > a.self-link {
    font-size: 83%;
}
li > a.self-link {
    left: calc(-1 * (3.5rem - 26px) - 2em);
}
dfn > a.self-link {
    top: auto;
    left: auto;
    opacity: 0;
    width: 1.5em;
    height: 1.5em;
    background: gray;
    color: white;
    font-style: normal;
    transition: opacity .2s, background-color .2s, color .2s;
}
dfn:hover > a.self-link {
    opacity: 1;
}
dfn > a.self-link:hover {
    color: black;
}

a.self-link::before            { content: "¶"; }
.heading > a.self-link::before { content: "§"; }
dfn > a.self-link::before      { content: "#"; }</style>
<style>/* style-counters */

body {
    counter-reset: example figure issue;
}
.issue {
    counter-increment: issue;
}
.issue:not(.no-marker)::before {
    content: "Issue " counter(issue);
}

.example {
    counter-increment: example;
}
.example:not(.no-marker)::before {
    content: "Example " counter(example);
}
.invalid.example:not(.no-marker)::before,
.illegal.example:not(.no-marker)::before {
    content: "Invalid Example" counter(example);
}

figcaption {
    counter-increment: figure;
}
figcaption:not(.no-marker)::before {
    content: "Figure " counter(figure) " ";
}</style>
<style>/* style-autolinks */

.css.css, .property.property, .descriptor.descriptor {
    color: #005a9c;
    font-size: inherit;
    font-family: inherit;
}
.css::before, .property::before, .descriptor::before {
    content: "‘";
}
.css::after, .property::after, .descriptor::after {
    content: "’";
}
.property, .descriptor {
    /* Don't wrap property and descriptor names */
    white-space: nowrap;
}
.type { /* CSS value <type> */
    font-style: italic;
}
pre .property::before, pre .property::after {
    content: "";
}
[data-link-type="property"]::before,
[data-link-type="propdesc"]::before,
[data-link-type="descriptor"]::before,
[data-link-type="value"]::before,
[data-link-type="function"]::before,
[data-link-type="at-rule"]::before,
[data-link-type="selector"]::before,
[data-link-type="maybe"]::before {
    content: "‘";
}
[data-link-type="property"]::after,
[data-link-type="propdesc"]::after,
[data-link-type="descriptor"]::after,
[data-link-type="value"]::after,
[data-link-type="function"]::after,
[data-link-type="at-rule"]::after,
[data-link-type="selector"]::after,
[data-link-type="maybe"]::after {
    content: "’";
}

[data-link-type].production::before,
[data-link-type].production::after,
.prod [data-link-type]::before,
.prod [data-link-type]::after {
    content: "";
}

[data-link-type=element],
[data-link-type=element-attr] {
    font-family: Menlo, Consolas, "DejaVu Sans Mono", monospace;
    font-size: .9em;
}
[data-link-type=element]::before { content: "<" }
[data-link-type=element]::after  { content: ">" }

[data-link-type=biblio] {
    white-space: pre;
}</style>
<style>/* style-dfn-panel */

.dfn-panel {
    position: absolute;
    z-index: 35;
    height: auto;
    width: -webkit-fit-content;
    width: fit-content;
    max-width: 300px;
    max-height: 500px;
    overflow: auto;
    padding: 0.5em 0.75em;
    font: small Helvetica Neue, sans-serif, Droid Sans Fallback;
    background: #DDDDDD;
    color: black;
    border: outset 0.2em;
}
.dfn-panel:not(.on) { display: none; }
.dfn-panel * { margin: 0; padding: 0; text-indent: 0; }
.dfn-panel > b { display: block; }
.dfn-panel a { color: black; }
.dfn-panel a:not(:hover) { text-decoration: none !important; border-bottom: none !important; }
.dfn-panel > b + b { margin-top: 0.25em; }
.dfn-panel ul { padding: 0; }
.dfn-panel li { list-style: inside; }
.dfn-panel.activated {
    display: inline-block;
    position: fixed;
    left: .5em;
    bottom: 2em;
    margin: 0 auto;
    max-width: calc(100vw - 1.5em - .4em - .5em);
    max-height: 30vh;
}

.dfn-paneled { cursor: pointer; }
</style>
<style>/* style-syntax-highlighting */

.highlight:not(.idl) { background: hsl(24, 20%, 95%); }
code.highlight { padding: .1em; border-radius: .3em; }
pre.highlight, pre > code.highlight { display: block; padding: 1em; margin: .5em 0; overflow: auto; border-radius: 0; }
c-[a] { color: #990055 } /* Keyword.Declaration */
c-[b] { color: #990055 } /* Keyword.Type */
c-[c] { color: #708090 } /* Comment */
c-[d] { color: #708090 } /* Comment.Multiline */
c-[e] { color: #0077aa } /* Name.Attribute */
c-[f] { color: #669900 } /* Name.Tag */
c-[g] { color: #222222 } /* Name.Variable */
c-[k] { color: #990055 } /* Keyword */
c-[l] { color: #000000 } /* Literal */
c-[m] { color: #000000 } /* Literal.Number */
c-[n] { color: #0077aa } /* Name */
c-[o] { color: #999999 } /* Operator */
c-[p] { color: #999999 } /* Punctuation */
c-[s] { color: #a67f59 } /* Literal.String */
c-[t] { color: #a67f59 } /* Literal.String.Single */
c-[u] { color: #a67f59 } /* Literal.String.Double */
c-[cp] { color: #708090 } /* Comment.Preproc */
c-[c1] { color: #708090 } /* Comment.Single */
c-[cs] { color: #708090 } /* Comment.Special */
c-[kc] { color: #990055 } /* Keyword.Constant */
c-[kn] { color: #990055 } /* Keyword.Namespace */
c-[kp] { color: #990055 } /* Keyword.Pseudo */
c-[kr] { color: #990055 } /* Keyword.Reserved */
c-[ld] { color: #000000 } /* Literal.Date */
c-[nc] { color: #0077aa } /* Name.Class */
c-[no] { color: #0077aa } /* Name.Constant */
c-[nd] { color: #0077aa } /* Name.Decorator */
c-[ni] { color: #0077aa } /* Name.Entity */
c-[ne] { color: #0077aa } /* Name.Exception */
c-[nf] { color: #0077aa } /* Name.Function */
c-[nl] { color: #0077aa } /* Name.Label */
c-[nn] { color: #0077aa } /* Name.Namespace */
c-[py] { color: #0077aa } /* Name.Property */
c-[ow] { color: #999999 } /* Operator.Word */
c-[mb] { color: #000000 } /* Literal.Number.Bin */
c-[mf] { color: #000000 } /* Literal.Number.Float */
c-[mh] { color: #000000 } /* Literal.Number.Hex */
c-[mi] { color: #000000 } /* Literal.Number.Integer */
c-[mo] { color: #000000 } /* Literal.Number.Oct */
c-[sb] { color: #a67f59 } /* Literal.String.Backtick */
c-[sc] { color: #a67f59 } /* Literal.String.Char */
c-[sd] { color: #a67f59 } /* Literal.String.Doc */
c-[se] { color: #a67f59 } /* Literal.String.Escape */
c-[sh] { color: #a67f59 } /* Literal.String.Heredoc */
c-[si] { color: #a67f59 } /* Literal.String.Interpol */
c-[sx] { color: #a67f59 } /* Literal.String.Other */
c-[sr] { color: #a67f59 } /* Literal.String.Regex */
c-[ss] { color: #a67f59 } /* Literal.String.Symbol */
c-[vc] { color: #0077aa } /* Name.Variable.Class */
c-[vg] { color: #0077aa } /* Name.Variable.Global */
c-[vi] { color: #0077aa } /* Name.Variable.Instance */
c-[il] { color: #000000 } /* Literal.Number.Integer.Long */
</style>
 <body class="h-entry">
  <div class="head">
   <p data-fill-with="logo"></p>
   <h1 class="p-name no-ref" id="title">P1144R0<br>Object relocation in terms of move plus destroy</h1>
   <h2 class="no-num no-toc no-ref heading settled" id="subtitle"><span class="content">Published Proposal, <time class="dt-updated" datetime="2018-10-04">2018-10-04</time></span></h2>
   <div data-fill-with="spec-metadata">
    <dl>
     <dt>Issue Tracking:
     <dd><a href="#issues-index">Inline In Spec</a>
     <dt>Authors:
     <dd>
      <dd class="editor p-author h-card vcard"><a class="p-name fn u-email email" href="mailto:arthur.j.odwyer@gmail.com">Arthur O'Dwyer</a>
     <dd>
      <dd class="editor p-author h-card vcard"><a class="p-name fn u-email email" href="mailto:wmx16835vv@163.com">Mingxin Wang</a>
     <dt>Audience:
     <dd>LEWG, EWG
     <dt>Project:
     <dd>ISO/IEC JTC1/SC22/WG21 14882: Programming Language — C++
     <dt>Current Source:
     <dd><a href="https://github.com/Quuxplusone/draft/blob/gh-pages/d1144.bs">github.com/Quuxplusone/draft/blob/gh-pages/d1144-object-relocation.bs</a>
     <dt>Current:
     <dd><a href="https://rawgit.com/Quuxplusone/draft/gh-pages/d1144.html">rawgit.com/Quuxplusone/draft/gh-pages/d1144-object-relocation.html</a>
    </dl>
   </div>
   <div data-fill-with="warning"></div>
   <hr title="Separator for header">
  </div>
  <div class="p-summary" data-fill-with="abstract">
   <h2 class="no-num no-toc no-ref heading settled" id="abstract"><span class="content">Abstract</span></h2>
   <p>We define a new verb, "relocate," which is tantamount to a move and a destroy

(analogous to the existing verb "swap," which is tantamount to a move, two move-assignments, and a destroy).
For many C++ types, the "relocate" operation is implementable as a single <code class="highlight"><c- n>memcpy</c-></code>.
We provide a standard trait to detect types which are trivially relocatable, for the benefit of library writers.
Finally, we provide a portable way for a user-defined type (e.g. <code class="highlight"><c- n>boost</c-><c- o>::</c-><c- n>shared_ptr</c-></code>) to warrant
to the implementation that it is trivially relocatable.</p>
  </div>
  <nav data-fill-with="table-of-contents" id="toc">
   <h2 class="no-num no-toc no-ref" id="contents">Table of Contents</h2>
   <ol class="toc" role="directory">
    <li>
     <a href="#intro"><span class="secno">1</span> <span class="content">Introduction and motivation</span></a>
     <ol class="toc">
      <li><a href="#applications"><span class="secno">1.1</span> <span class="content">Optimizations enabled by trivial relocatability</span></a>
      <li><a href="#doing-it-wrong"><span class="secno">1.2</span> <span class="content">Real-world code already does it wrong</span></a>
     </ol>
    <li>
     <a href="#design-goals"><span class="secno">2</span> <span class="content">Design goals</span></a>
     <ol class="toc">
      <li><a href="#use1"><span class="secno">2.1</span> <span class="content">Standard library types such as <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>string</c-></code></span></a>
      <li><a href="#use2"><span class="secno">2.2</span> <span class="content">Program-defined types that follow the Rule of Zero</span></a>
      <li><a href="#use3"><span class="secno">2.3</span> <span class="content">Program-defined types with non-defaulted special members</span></a>
     </ol>
    <li><a href="#proposal"><span class="secno">3</span> <span class="content">Proposed language and library features</span></a>
    <li>
     <a href="#wording"><span class="secno">4</span> <span class="content">Proposed wording for C++20</span></a>
     <ol class="toc">
      <li><a href="#wording-operation"><span class="secno">4.1</span> <span class="content">Relocation operation</span></a>
      <li><a href="#wording-uninit-relocate"><span class="secno">4.2</span> <span class="content">Algorithm <code class="highlight"><c- n>uninitialized_relocate</c-></code></span></a>
      <li><a href="#wording-uninit-relocate-n"><span class="secno">4.3</span> <span class="content">Algorithm <code class="highlight"><c- n>uninitialized_relocate_n</c-></code></span></a>
      <li><a href="#wording-inheritance"><span class="secno">4.4</span> <span class="content">Trivially relocatable type</span></a>
      <li><a href="#wording-attribute"><span class="secno">4.5</span> <span class="content"><code class="highlight"><c- p>[[</c-><c- n>trivially_relocatable</c-><c- p>]]</c-></code> attribute</span></a>
      <li><a href="#wording-traits"><span class="secno">4.6</span> <span class="content">Type traits <code class="highlight"><c- n>is_relocatable</c-></code> etc.</span></a>
      <li><a href="#wording-concept"><span class="secno">4.7</span> <span class="content"><code class="highlight"><c- n>Relocatable</c-></code> concept</span></a>
     </ol>
    <li>
     <a href="#further"><span class="secno">5</span> <span class="content">Further considerations and directions</span></a>
     <ol class="toc">
      <li><a href="#trivially-swappable"><span class="secno">5.1</span> <span class="content">Trivially swappable types</span></a>
      <li><a href="#hetero"><span class="secno">5.2</span> <span class="content">Heterogeneous relocation</span></a>
     </ol>
    <li><a href="#acknowledgements"><span class="secno">6</span> <span class="content">Acknowledgements</span></a>
    <li>
     <a href="#polls"><span class="secno"></span> <span class="content">Appendix A: Straw polls</span></a>
     <ol class="toc">
      <li><a href="#taken-polls"><span class="secno"></span> <span class="content">Polls taken of SG14 on 2018-09-26</span></a>
      <li><a href="#lewg-polls"><span class="secno"></span> <span class="content">Polls requested of LEWG in San Diego</span></a>
      <li><a href="#ewg-polls"><span class="secno"></span> <span class="content">Polls requested of EWG in San Diego</span></a>
     </ol>
    <li>
     <a href="#samples"><span class="secno"></span> <span class="content">Appendix B: Sample code</span></a>
     <ol class="toc">
      <li><a href="#sample-deducing"><span class="secno"></span> <span class="content">Defining a trivially relocatable function object</span></a>
      <li><a href="#sample-opting-in"><span class="secno"></span> <span class="content">Warranting that a user-defined relocation operation is equivalent to <code class="highlight"><c- n>memcpy</c-></code></span></a>
      <li><a href="#sample-uninit-relocate"><span class="secno"></span> <span class="content">Reference implementation of <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>uninitialized_relocate</c-></code></span></a>
      <li><a href="#sample-conditional"><span class="secno"></span> <span class="content">Conditionally trivial relocation</span></a>
     </ol>
    <li>
     <a href="#non-trivial-samples"><span class="secno"></span> <span class="content">Appendix C: Examples of non-trivially relocatable class types</span></a>
     <ol class="toc">
      <li><a href="#non-trivial-sample-string"><span class="secno"></span> <span class="content">Class contains pointer to self</span></a>
      <li><a href="#non-trivial-sample-list"><span class="secno"></span> <span class="content">Allocated memory contains pointer to self</span></a>
      <li><a href="#non-trivial-sample-offset-ptr"><span class="secno"></span> <span class="content">Class invariant depends on <code class="highlight"><c- k>this</c-></code></span></a>
      <li><a href="#non-trivial-sample-registry"><span class="secno"></span> <span class="content">Program invariant depends on <code class="highlight"><c- k>this</c-></code></span></a>
     </ol>
    <li><a href="#implementation"><span class="secno"></span> <span class="content">Appendix D: Implementation and benchmarks</span></a>
    <li>
     <a href="#index"><span class="secno"></span> <span class="content">Index</span></a>
     <ol class="toc">
      <li><a href="#index-defined-here"><span class="secno"></span> <span class="content">Terms defined by this specification</span></a>
     </ol>
    <li>
     <a href="#references"><span class="secno"></span> <span class="content">References</span></a>
     <ol class="toc">
      <li><a href="#normative"><span class="secno"></span> <span class="content">Normative References</span></a>
      <li><a href="#informative"><span class="secno"></span> <span class="content">Informative References</span></a>
     </ol>
    <li><a href="#issues-index"><span class="secno"></span> <span class="content">Issues Index</span></a>
   </ol>
  </nav>
  <main>
   <h2 class="heading settled" data-level="1" id="intro"><span class="secno">1. </span><span class="content">Introduction and motivation</span><a class="self-link" href="#intro"></a></h2>
   <p>If you are reading this paper, and you have not yet watched Arthur’s session from C++Now 2018
on <a data-link-type="biblio" href="#biblio-best">"The Best Type Traits C++ Doesn’t Have,"</a> you might want to <a href="https://www.youtube.com/watch?v=MWBfmmg8-Yo">go watch</a> the first 30 minutes of that video at 2x speed with the captions turned on.
It’ll be worth your 15 minutes.</p>
   <p>In the video, besides showing implementation techniques and benchmark results, we defined our
terms. These terms are summarized briefly below.</p>
   <p>C++17 knows the verbs "move," "copy," "destroy," and "swap," where "swap" is a higher-level operation
composed of several lower-level operations. To this list we propose to add the verb "relocate,"
which is a higher-level operation composed of exactly two lower-level operations.
Given an object type <code class="highlight"><c- n>T</c-></code> and memory addresses <code class="highlight"><c- n>src</c-></code> and <code class="highlight"><c- n>dst</c-></code>,
the phrase "<b><i>relocate</i></b> a <code class="highlight"><c- n>T</c-></code> from <code class="highlight"><c- n>src</c-></code> to <code class="highlight"><c- n>dst</c-></code>" means no more and no
less than "<em>move-construct</em> <code class="highlight"><c- n>dst</c-></code> from <code class="highlight"><c- n>src</c-></code>, and then immediately <em>destroy</em> the object at <code class="highlight"><c- n>src</c-></code>."</p>
   <p>Just as the verb "swap" produces the adjective "swappable," the verb "relocate" produces the adjective
"relocatable." Any type which is both move-constructible and
destructible is <b><i>relocatable</i></b>. The notion can be modified by adverbs: we say that a type
is <b><i>nothrow relocatable</i></b> if its relocation operation is noexcept, and we say that a type
is <b><i><a data-link-type="abstract-op" href="#abstract-opdef-trivially-relocatable" id="ref-for-abstract-opdef-trivially-relocatable">trivially relocatable</a></i></b> if its relocation operation is trivial (which, just like trivial move-construction
and trivial copy-construction, means "the operation is tantamount to a <code class="highlight"><c- n>memcpy</c-></code>").</p>
   <p>Almost all relocatable types are trivially relocatable: <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>unique_ptr</c-><c- o>&lt;</c-><c- b>int</c-><c- o>></c-></code>, <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- b>int</c-><c- o>></c-></code>, <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>string</c-></code>. Non-trivially relocatable types
exist but are rare; see <a href="#non-trivial-samples">Appendix C: Examples of non-trivially relocatable class types</a>.</p>
   <h3 class="heading settled" data-level="1.1" id="applications"><span class="secno">1.1. </span><span class="content">Optimizations enabled by trivial relocatability</span><a class="self-link" href="#applications"></a></h3>
   <p>A reliable way of detecting "trivial relocatability"
permits optimizing routines that perform the moral equivalent of <code class="highlight"><c- n>realloc</c-></code>, such as</p>
<pre class="language-c++ highlight">    <c- n>std</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- n>R</c-><c- o>>::</c-><c- n>resize</c->
    <c- n>std</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- n>R</c-><c- o>>::</c-><c- n>reserve</c->
    <c- n>std</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- n>R</c-><c- o>>::</c-><c- n>emplace_back</c->
    <c- n>std</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- n>R</c-><c- o>>::</c-><c- n>push_back</c->
</pre>
   <p><a data-link-type="biblio" href="#biblio-bench">[Bench]</a> shows a 3x speedup on <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>unique_ptr</c-><c- o>&lt;</c-><c- b>int</c-><c- o>>>::</c-><c- n>resize</c-></code>.
Just as with C++11 move semantics, you can write benchmarks to show whatever speedup
you like: The more complicated your types' move-constructors and destructors,
the more time you save by eliminating calls to them.</p>
   <p>A reliable way of detecting "trivial relocatability"
permits optimizing routines that rely on the moral equivalent of <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>swap</c-></code>, such as</p>
<pre class="language-c++ highlight">    <c- n>std</c-><c- o>::</c-><c- n>swap</c->
    <c- n>std</c-><c- o>::</c-><c- n>sort</c->
    <c- n>std</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- n>R</c-><c- o>>::</c-><c- n>insert</c-> <c- p>(</c-><c- n>arguably</c-><c- p>)</c->
</pre>
   <p>A reliable way of detecting "trivial relocatability"
permits de-duplicating the code generated by small-buffer-optimized (SBO) type-erasing wrappers
such as <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>function</c-></code> and <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>any</c-></code>.
For these types, a <em>move</em> of the wrapper object is implemented in terms of a <em>relocation</em> of the contained object. (See for example <a data-link-type="biblio" href="#biblio-libcxxany">libc++'s std::any</a>,
where the function that performs the relocation operation is confusingly named <code class="highlight"><c- n>__move</c-></code>.)
In general, the <em>relocate</em> operation for a contained type <code class="highlight"><c- n>C</c-></code> must be uniquely codegenned for each
different <code class="highlight"><c- n>C</c-></code>, leading to code bloat. But a single instantiation suffices to relocate every <em>trivially</em> relocatable <code class="highlight"><c- n>C</c-></code> in the program. A smaller number of instantiations means faster compile times,
a smaller text section, and "hotter" code (because a relatively higher proportion of your
code now fits in icache).</p>
   <p>A reliable way of detecting "trivial relocatability"
permits optimizing the move-constructor of <code class="highlight"><c- n>fixed_capacity_vector</c-><c- o>&lt;</c-><c- n>R</c-><c- p>,</c-><c- n>N</c-><c- o>></c-></code>,
which can be implemented naïvely as an element-by-element <em>move</em> (leaving the source vector’s elements in their moved-from state),
or can be implemented efficiently as an element-by-element <em>relocate</em> (leaving the source vector empty).</p>
   <p class="note" role="note"><span>Note:</span> <code class="highlight"><c- n>boost</c-><c- o>::</c-><c- n>container</c-><c- o>::</c-><c- n>static_vector</c-><c- o>&lt;</c-><c- n>R</c-><c- p>,</c-><c- n>N</c-><c- o>></c-></code> currently implements the
naïve element-by-element-move strategy.</p>
   <p>Finally, some concurrent data structures might reasonably assert the trivial relocatability of
their elements, just as they sometimes assert the stronger property of trivial <em>copyability</em> today.</p>
   <h3 class="heading settled" data-level="1.2" id="doing-it-wrong"><span class="secno">1.2. </span><span class="content">Real-world code already does it wrong</span><a class="self-link" href="#doing-it-wrong"></a></h3>
   <p>Many real-world codebases already contain templates which require
trivial relocatability of their template parameters, but currently have no way to <em>verify</em> trivial relocatability. For example, <a data-link-type="biblio" href="#biblio-folly">[Folly]</a> requires the programmer to warrant the trivial
relocatability of any type stored in a <code class="highlight"><c- n>folly</c-><c- o>::</c-><c- n>fbvector</c-></code>:</p>
<pre class="language-c++ highlight">    <c- n>class</c-> <c- n>Widget</c-> <c- p>{</c->
        <c- n>std</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- b>int</c-><c- o>></c-> <c- n>lst_</c-><c- p>;</c->
    <c- p>};</c->

    <c- n>folly</c-><c- o>::</c-><c- n>fbvector</c-><c- o>&lt;</c-><c- n>Widget</c-><c- o>></c-> <c- n>vec</c-><c- p>;</c->  <c- c1>// FAILS AT COMPILE TIME for lack of warrant</c->
</pre>
   <p>But this merely encourages the programmer to add the warrant and continue. An incorrect
warrant will be discovered only at runtime, via undefined behavior. (See <a href="#non-trivial-sample-list">Allocated memory contains pointer to self</a> and <a data-link-type="biblio" href="#biblio-follyissue889">[FollyIssue889]</a>.)</p>
<pre class="language-c++ highlight">    <c- n>class</c-> <c- n>Gadget</c-> <c- p>{</c->
        <c- n>std</c-><c- o>::</c-><c- n>list</c-><c- o>&lt;</c-><c- b>int</c-><c- o>></c-> <c- n>lst_</c-><c- p>;</c->
    <c- p>};</c->
    <c- c1>// sigh, add the warrant on autopilot</c->
    <c- n>template</c-><c- o>&lt;></c-> <c- k>struct</c-> <c- n>folly</c-><c- o>::</c-><c- n>IsRelocatable</c-><c- o>&lt;</c-><c- n>Gadget</c-><c- o>></c-> <c- o>:</c-> <c- n>std</c-><c- o>::</c-><c- n>true_type</c-> <c- p>{};</c->

    <c- n>folly</c-><c- o>::</c-><c- n>fbvector</c-><c- o>&lt;</c-><c- n>Gadget</c-><c- o>></c-> <c- n>vec</c-><c- p>;</c->  <c- c1>// CRASHES AT RUNTIME due to fraudulent warrant</c->
</pre>
   <p>If this proposal is adopted, then Folly can start using <code class="highlight"><c- k>static_assert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>is_trivially_relocatable_v</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-><c- p>)</c-></code> in the implementation of <code class="highlight"><c- n>fbvector</c-></code>, and the programmer can stop writing explicit warrants in the vast majority
of cases. Finally, the programmer can start writing assertions of correctness, which aids maintainability and
can even find real bugs. Example:</p>
<pre class="language-c++ highlight">    <c- n>class</c-> <c- n>Widget</c-> <c- p>{</c->
        <c- n>std</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- b>int</c-><c- o>></c-> <c- n>lst_</c-><c- p>;</c->
    <c- p>};</c->
    <c- n>static_assert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>is_trivially_relocatable_v</c-><c- o>&lt;</c-><c- n>Widget</c-><c- o>></c-><c- p>);</c->  <c- c1>// correctly SUCCEEDS</c->

    <c- n>class</c-> <c- n>Gadget</c-> <c- p>{</c->
        <c- n>std</c-><c- o>::</c-><c- n>list</c-><c- o>&lt;</c-><c- b>int</c-><c- o>></c-> <c- n>lst_</c-><c- p>;</c->
    <c- p>};</c->
    <c- n>static_assert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>is_trivially_relocatable_v</c-><c- o>&lt;</c-><c- n>Gadget</c-><c- o>></c-><c- p>);</c->  <c- c1>// correctly ERRORS OUT</c->
</pre>
   <p>The improvement in user experience for real-world codebases (such as <a data-link-type="biblio" href="#biblio-folly">[Folly]</a>, <a data-link-type="biblio" href="#biblio-eastl">[EASTL]</a>, BDE, Qt, etc.)
is the most important benefit to be gained by this proposal.</p>
   <h2 class="heading settled" data-level="2" id="design-goals"><span class="secno">2. </span><span class="content">Design goals</span><a class="self-link" href="#design-goals"></a></h2>
   <p>Every C++ type already <em>is</em> or <em>is not</em> trivially relocatable. This proposal does not require any
library vendor to make any library type trivially relocatable (but we assume that quality implementations
will do so on their own).</p>
   <p>The optimizations discussed above are purely in the domain of library writers. If you’re writing
a vector, and you detect that your element type <code class="highlight"><c- n>T</c-></code> is trivially relocatable, then
whether you do any special optimization in that case is up to you.
This proposal does not require any library vendor to guarantee that any particular optimization
happens (but we assume that quality implementations will do so on their own).</p>
   <p>What C++ lacks is a standard way for library writers to <em>detect</em> the (existing) trivial relocatability
of a type <code class="highlight"><c- n>T</c-></code>, so that they can reliably apply their (existing) optimizations.
All we really need is to add <em>detection</em>, and then all the optimizations described above will naturally
emerge without any further special effort by WG21.</p>
   <p>The following three use-cases are important for improving the performance of real programs using
the standard library, and for improving the correctness of real programs using libraries such as <a data-link-type="biblio" href="#biblio-folly">[Folly]</a>'s <code class="highlight"><c- n>fbvector</c-></code>:</p>
   <h3 class="heading settled" data-level="2.1" id="use1"><span class="secno">2.1. </span><span class="content">Standard library types such as <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>string</c-></code></span><a class="self-link" href="#use1"></a></h3>
   <p>In order to optimize <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>string</c-><c- o>>::</c-><c- n>resize</c-></code>, we must come up with a way to achieve</p>
<pre class="language-c++ highlight">    <c- cp>#include</c-> &lt;string>
    <c- n>static_assert</c-><c- p>(</c-><c- n>is_trivially_relocatable</c-><c- o>&lt;</c-> <c- n>std</c-><c- o>::</c-><c- n>string</c-> <c- o>>::</c-><c- n>value</c-><c- p>);</c->
</pre>
   This could be done unilaterally by the library vendor, via a non-standard attribute
(<code class="highlight"><c- p>[[</c-><c- n>clang</c-><c- o>::</c-><c- n>trivially_relocatable</c-><c- p>]]</c-></code>), or a member typedef with a reserved name
(<code class="highlight"><c- k>using</c-> <c- n>__is_triv_relocatable</c-> <c- o>=</c-> <c- b>void</c-></code>), or simply a vendor-provided specialization
of <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>is_trivially_relocatable</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>string</c-><c- o>></c-></code>. 
   <p>That is, we can in principle solve §2.1 while confining our "magic" to the headers
of the implementation itself. The programmer doesn’t have to learn anything new, so far.</p>
   <h3 class="heading settled" data-level="2.2" id="use2"><span class="secno">2.2. </span><span class="content">Program-defined types that follow the Rule of Zero</span><a class="self-link" href="#use2"></a></h3>
   <p class="note" role="note"><span>Note:</span> The term "program-defined types" is defined in <a data-link-type="biblio" href="#biblio-lwg2139">[LWG2139]</a> and <a data-link-type="biblio" href="#biblio-lwg3119">[LWG3119]</a>.</p>
   <p>In order to optimize the SBO <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>function</c-></code> in any meaningful sense,
we must come up with a way to achieve</p>
<pre class="language-c++ highlight">    <c- cp>#include</c-> &lt;string>
    <c- k>auto</c-> <c- n>lam2</c-> <c- o>=</c-> <c- p>[</c-><c- n>x</c-><c- o>=</c-><c- n>std</c-><c- o>::</c-><c- n>string</c-><c- p>(</c-><c- s>"hello"</c-><c- p>)]{};</c->
    <c- n>static_assert</c-><c- p>(</c-><c- n>is_trivially_relocatable</c-><c- o>&lt;</c-> <c- n>decltype</c-><c- p>(</c-><c- n>lam2</c-><c- p>)</c-> <c- o>>::</c-><c- n>value</c-><c- p>);</c->
</pre>
   Lambdas are not a special case in C++; they are simply class types with all their special members defaulted.
Therefore, presumably we should be able to use the same solution for lambdas as for 
<pre class="language-c++ highlight">    <c- cp>#include</c-> &lt;string>
    <c- k>struct</c-> <c- n>A</c-> <c- p>{</c->
        <c- n>std</c-><c- o>::</c-><c- n>string</c-> <c- n>s</c-><c- p>;</c->
    <c- p>};</c->
    <c- n>static_assert</c-><c- p>(</c-><c- n>is_trivially_relocatable</c-><c- o>&lt;</c-> <c- n>A</c-> <c- o>>::</c-><c- n>value</c-><c- p>);</c->
</pre>
   Here <code class="highlight"><c- k>struct</c-> <c- n>A</c-></code> follows the Rule of Zero: its move-constructor and destructor are both defaulted.
If they were also <em>trivial</em>, then we’d be done. In fact they are non-trivial; and yet, because the type’s
bases and members are all of trivially relocatable types, the type as a whole <em>is</em> trivially relocatable. 
   <p>§2.2 asks specifically that we make the <code class="highlight"><c- k>static_assert</c-></code> succeed without breaking the "Rule of Zero."
We do not want to require the programmer to annotate <code class="highlight"><c- k>struct</c-> <c- n>A</c-></code> with a special attribute, or
a special member typedef, or anything like that. We want it to Just Work. Even for lambda types.
This is a much harder problem than §2.1; it requires standard support in the core language.
But it still does not require any new <em>syntax</em>.</p>
   <h3 class="heading settled" data-level="2.3" id="use3"><span class="secno">2.3. </span><span class="content">Program-defined types with non-defaulted special members</span><a class="self-link" href="#use3"></a></h3>
   <p>In order to optimize <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- n>boost</c-><c- o>::</c-><c- n>shared_ptr</c-><c- o>&lt;</c-><c- n>T</c-><c- o>>>::</c-><c- n>resize</c-></code>,
we must come up with a way to achieve</p>
<pre class="language-c++ highlight">    <c- k>struct</c-> <c- n>B</c-> <c- p>{</c->
        <c- n>B</c-><c- p>(</c-><c- n>B</c-><c- o>&amp;&amp;</c-><c- p>);</c->  <c- c1>// non-trivial</c->
        <c- o>~</c-><c- n>B</c-><c- p>();</c->  <c- c1>// non-trivial</c->
    <c- p>};</c->
    <c- n>static_assert</c-><c- p>(</c-><c- n>is_trivially_relocatable</c-><c- o>&lt;</c-> <c- n>B</c-> <c- o>>::</c-><c- n>value</c-><c- p>);</c->
</pre>
   via some kind of programmer-provided annotation. 
   <p class="note" role="note"><span>Note:</span> We cannot possibly do it without annotation, because there exist
examples of types that look just like <code class="highlight"><c- n>B</c-></code> and <em>are</em> trivially relocatable (for example, <a data-link-type="biblio" href="#biblio-libstdcxxfunction">libstdc++'s std::function</a>) and there exist types that look just like <code class="highlight"><c- n>B</c-></code> and are <em>not</em> trivially relocatable (for example, <a data-link-type="biblio" href="#biblio-libcxxfunction">libc++'s std::function</a>).
The compiler cannot "crack open" the definitions of <code class="highlight"><c- n>B</c-><c- p>(</c-><c- n>B</c-><c- o>&amp;&amp;</c-><c- p>)</c-></code> and <code class="highlight"><c- o>~</c-><c- n>B</c-><c- p>()</c-></code> to see if
they combine to form a trivial operation. One, that’s the Halting Problem. Two,
the definitions of <code class="highlight"><c- n>B</c-><c- p>(</c-><c- n>B</c-><c- o>&amp;&amp;</c-><c- p>)</c-></code> and <code class="highlight"><c- o>~</c-><c- n>B</c-><c- p>()</c-></code> might not be available in this translation
unit. Three, the definitions might actually be
available and "crackable" in <em>this</em> translation unit, but unavailable in some other translation unit!
This would lead to ODR violations and generally really bad stuff. So we cannot achieve
our goal by avoiding annotation.</p>
   <p>This use-case is the only one that requires us to design the "opt-in" syntax.
In <a href="#use1">§2.1 Standard library types such as std::string</a>, any special syntax is hidden inside the
implementation’s own headers. In <a href="#use2">§2.2 Program-defined types that follow the Rule of Zero</a>, our design goal is to <em>avoid</em> special syntax.
In <a href="#use3">§2.3 Program-defined types with non-defaulted special members</a>, WG21 must actually design user-facing syntax.</p>
   <p>Therefore, I believe it would be acceptable to punt on §2.3 and come back to it later.
We say, "Sure, that would be nice, but there’s no syntax for it. Be glad that it works for
core-language and library types. Ask again in three years."  And as long as we leave the design
space open, I believe we wouldn’t lose anything by delaying a solution to §2.3.</p>
   <p>This paper does propose a standard syntax for §2.3 — an attribute — which in turn
provides a <em>simple and portable</em> solution to §2.1 for library vendors. However, our
attribute-based syntax is severable from the rest of this paper. With extremely minor surgery,
WG21 could reject our new attribute and still solve §2.1 and §2.2 for C++20.</p>
   <h2 class="heading settled" data-level="3" id="proposal"><span class="secno">3. </span><span class="content">Proposed language and library features</span><a class="self-link" href="#proposal"></a></h2>
   <p>This paper proposes five separate additions to the C++ Standard. These additions introduce
"relocate" as a well-supported C++ notion on par with "swap," and furthermore, successfully
communicate trivial relocatability in each of the three use-cases above.</p>
   <ul>
    <li data-md>
     <p>A new standard algorithm, <code class="highlight"><c- n>uninitialized_relocate</c-><c- p>(</c-><c- n>first</c-><c- p>,</c-> <c- n>last</c-><c- p>,</c-> <c- n>d_first</c-><c- p>)</c-></code>,
in the <code class="highlight"><c- o>&lt;</c-><c- n>memory</c-><c- o>></c-></code> header.</p>
    <li data-md>
     <p>Additional type traits, <code class="highlight"><c- n>is_relocatable</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-></code> and <code class="highlight"><c- n>is_nothrow_relocatable</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-></code>,
in the <code class="highlight"><c- o>&lt;</c-><c- n>type_traits</c-><c- o>></c-></code> header.</p>
    <li data-md>
     <p>A new type trait, <code class="highlight"><c- n>is_trivially_relocatable</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-></code>, in the <code class="highlight"><c- o>&lt;</c-><c- n>type_traits</c-><c- o>></c-></code> header. This is the <em>detection</em> mechanism.</p>
    <li data-md>
     <p>A new core-language rule by which a class type’s "trivial relocatability"
is inherited according to the Rule of Zero.</p>
    <li data-md>
     <p>A new attribute, <code class="highlight"><c- p>[[</c-><c- n>trivially_relocatable</c-><c- p>]]</c-></code>, in the core language.
This is the <em>opt-in</em> mechanism for program-defined types.</p>
   </ul>
   <p>These five bullet points are severable to a certain degree. For example, if the <code class="highlight"><c- p>[[</c-><c- n>trivially_relocatable</c-><c- p>]]</c-></code> attribute (point 5) is adopted, library vendors will certainly use it in their implementations;
but if the attribute is rejected, library vendors could still indicate the trivial relocatability
for certain standard library types by providing library specializations of <code class="highlight"><c- n>is_trivially_relocatable</c-></code> (point 3).</p>
   <p>Points 1 and 2 are completely severable from points 3, 4, and 5;
but we believe these algorithms should be provided for symmetry with the
other uninitialized-memory algorithms in the <code class="highlight"><c- o>&lt;</c-><c- n>memory</c-><c- o>></c-></code> header
(e.g. <code class="highlight"><c- n>uninitialized_move</c-></code>)
and the other trios of type-traits in the <code class="highlight"><c- o>&lt;</c-><c- n>type_traits</c-><c- o>></c-></code> header
(e.g. <code class="highlight"><c- n>is_destructible</c-></code>, <code class="highlight"><c- n>is_nothrow_destructible</c-></code>, <code class="highlight"><c- n>is_trivially_destructible</c-></code>). I do not expect these templates to be frequently useful,
but I believe they must be provided, so as not to unpleasantly surprise the programmer
by their absence.</p>
   <p>Points 3 and 4 together motivate point 5. In order to achieve the goal of <a href="#use2">§2.2 Program-defined types that follow the Rule of Zero</a>,
we <em>must</em> define a core-language mechanism by which we can "inherit" trivial relocatability.
This is especially important for the template case.</p>
<pre class="language-c++ highlight">    <c- n>template</c-><c- o>&lt;</c-><c- n>class</c-> <c- n>T</c-><c- o>></c->
    <c- k>struct</c-> <c- n>D</c-> <c- p>{</c->
        <c- n>T</c-> <c- n>t</c-><c- p>;</c->
    <c- p>};</c->

    <c- c1>// class C comes in from outside, already marked, via whatever mechanism</c->
    <c- n>constexpr</c-> <c- b>bool</c-> <c- n>c</c-> <c- o>=</c-> <c- n>is_trivially_relocatable</c-><c- o>&lt;</c-> <c- n>C</c-> <c- o>>::</c-><c- n>value</c-><c- p>;</c->
    <c- n>constexpr</c-> <c- b>bool</c-> <c- n>dc</c-> <c- o>=</c-> <c- n>is_trivially_relocatable</c-><c- o>&lt;</c-> <c- n>D</c-><c- o>&lt;</c-><c- n>C</c-><c- o>></c-> <c- o>>::</c-><c- n>value</c-><c- p>;</c->
    <c- n>static_assert</c-><c- p>(</c-><c- n>dc</c-> <c- o>==</c-> <c- n>c</c-><c- p>);</c->
</pre>
   We strongly believe that <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>is_trivially_relocatable</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-></code> should be just a plain old
class template, exactly like <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>is_trivially_destructible</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-></code> and so on.
The core language <em><a data-link-type="biblio" href="#biblio-contra">should not know or care</a></em> that the class template <code class="highlight"><c- n>is_trivially_relocatable</c-></code> exists, any more than it knows that the class template <code class="highlight"><c- n>is_trivially_destructible</c-></code> exists. 
   <p>We expect that the library vendor will implement <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>is_trivially_relocatable</c-></code>,
just like <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>is_trivially_destructible</c-></code>, in terms of a non-standard compiler
builtin whose natural spelling is <code class="highlight"><c- n>__is_trivially_relocatable</c-><c- p>(</c-><c- n>T</c-><c- p>)</c-></code>. The compiler
computes the value of <code class="highlight"><c- n>__is_trivially_relocatable</c-><c- p>(</c-><c- n>T</c-><c- p>)</c-></code> by inspecting the
definition of <code class="highlight"><c- n>T</c-></code> (and the definitions of its base classes and members,
recursively, in the case that both of its special members are defaulted). This
recursive process "bottoms out" at primitive types, or at any type with a user-provided
move or destroy operation. For safety, classes with user-provided move or destroy operations
(e.g. <a href="#non-trivial-samples">Appendix C: Examples of non-trivially relocatable class types</a>) must be assumed <em>not</em> to be trivially relocatable. To achieve the goal
of <a href="#use3">§2.3 Program-defined types with non-defaulted special members</a>, we must provide a way that such a class can "opt in" and warrant to the
implementation that it is in fact trivially relocatable (despite being non-trivially
move-constructible and/or non-trivially destructible).</p>
   <p>In point 5 we propose that the opt-in mechanism should be an attribute. The programmer
of a trivially relocatable but non-trivially destructible class <code class="highlight"><c- n>C</c-></code> will mark it for
the compiler using the attribute:</p>
<pre class="language-c++ highlight">    <c- k>struct</c-> <c- p>[[</c-><c- n>trivially_relocatable</c-><c- p>]]</c-> <c- n>C</c-> <c- p>{</c->
        <c- n>C</c-><c- p>(</c-><c- n>C</c-><c- o>&amp;&amp;</c-><c- p>);</c->  <c- c1>// defined elsewhere</c->
        <c- o>~</c-><c- n>C</c-><c- p>();</c-> <c- c1>// defined elsewhere</c->
    <c- p>};</c->
    <c- n>static_assert</c-><c- p>(</c-><c- n>is_trivially_relocatable</c-><c- o>&lt;</c-> <c- n>C</c-> <c- o>>::</c-><c- n>value</c-><c- p>);</c->
</pre>
   The attribute overrides the compiler’s usual computation. An example of a "conditionally"
trivially relocatable class is shown in <a href="#sample-conditional">Conditionally trivial relocation</a>. 
   <p>Again, the attribute <em>is</em> severable; WG21 could adopt all the rest of this proposal and
leave vendors to implement <code class="highlight"><c- p>[[</c-><c- n>clang</c-><c- o>::</c-><c- n>trivially_relocatable</c-><c- p>]]</c-></code>, <code class="highlight"><c- p>[[</c-><c- n>gnu</c-><c- o>::</c-><c- n>trivially_relocatable</c-><c- p>]]</c-></code>, etc.,
as non-standard extension mechanisms.
In that case, we would strike <a href="#wording-attribute">§4.5</a> and one bullet point from <a href="#wording-inheritance">§4.4</a>;
the rest of the proposal would remain the same.</p>
   <h2 class="heading settled" data-level="4" id="wording"><span class="secno">4. </span><span class="content">Proposed wording for C++20</span><a class="self-link" href="#wording"></a></h2>
   <p>The wording in this section is relative to <a data-link-type="biblio" href="#biblio-n4750">WG21 draft N4750</a>,
that is, the current draft of the C++17 standard.</p>
   <h3 class="heading settled" data-level="4.1" id="wording-operation"><span class="secno">4.1. </span><span class="content">Relocation operation</span><a class="self-link" href="#wording-operation"></a></h3>
   <p>Add a new section in <a href="http://eel.is/c++draft/definitions">[definitions]</a>:</p>
   <p class="issue" id="issue-75ffe201"><a class="self-link" href="#issue-75ffe201"></a> [definitions] is probably the wrong place for the core-language definition of "relocation operation"</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <dl><dt data-md><dfn class="dfn-paneled" data-dfn-type="abstract-op" data-export id="abstract-opdef-relocation-operation">relocation operation</dfn></dt><dd data-md><p>the homogeneous binary operation performed on a range by <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>uninitialized_relocate</c-></code>, consisting of a move-construction immediately followed by a destruction of the source object</p> </dd></dl> </small>
   </blockquote>
   <p class="issue" id="issue-7c86f5f7"><a class="self-link" href="#issue-7c86f5f7"></a> this definition of "relocation operation" is not good</p>
   <h3 class="heading settled" data-level="4.2" id="wording-uninit-relocate"><span class="secno">4.2. </span><span class="content">Algorithm <code class="highlight"><c- n>uninitialized_relocate</c-></code></span><a class="self-link" href="#wording-uninit-relocate"></a></h3>
   <p>Add a new section after <a href="http://eel.is/c++draft/uninitialized.move">[uninitialized.move]</a>:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>ForwardIterator</c-><c- o>></c->
<c- n>ForwardIterator</c-> <c- n>uninitialized_relocate</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c->
                                       <c- n>ForwardIterator</c-> <c- n>result</c-><c- p>);</c->
</pre> <p><em>Effects:</em> Equivalent to:</p> <pre class="highlight"><c- k>for</c-> <c- p>(;</c-> <c- n>first</c-> <c- o>!=</c-> <c- n>last</c-><c- p>;</c-> <c- p>(</c-><c- b>void</c-><c- p>)</c-><c- o>++</c-><c- n>result</c-><c- p>,</c-> <c- o>++</c-><c- n>first</c-><c- p>)</c-> <c- p>{</c->
  <c- o>::</c-><c- k>new</c-> <c- p>(</c-><c- k>static_cast</c-><c- o>&lt;</c-><c- b>void</c-><c- o>*></c-><c- p>(</c-><c- n>addressof</c-><c- p>(</c-><c- o>*</c-><c- n>result</c-><c- p>)))</c->
    <c- k>typename</c-> <c- n>iterator_traits</c-><c- o>&lt;</c-><c- n>ForwardIterator</c-><c- o>>::</c-><c- n>value_type</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- o>*</c-><c- n>first</c-><c- p>));</c->
  <c- n>destroy_at</c-><c- p>(</c-><c- n>addressof</c-><c- p>(</c-><c- o>*</c-><c- n>first</c-><c- p>));</c->
<c- p>}</c->
<c- k>return</c-> <c- n>result</c-><c- p>;</c->
</pre></small>
   </blockquote>
   <h3 class="heading settled" data-level="4.3" id="wording-uninit-relocate-n"><span class="secno">4.3. </span><span class="content">Algorithm <code class="highlight"><c- n>uninitialized_relocate_n</c-></code></span><a class="self-link" href="#wording-uninit-relocate-n"></a></h3>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Size</c-><c- p>,</c-> <c- k>class</c-> <c- nc>ForwardIterator</c-><c- o>></c->
  <c- n>pair</c-><c- o>&lt;</c-><c- n>InputIterator</c-><c- p>,</c-> <c- n>ForwardIterator</c-><c- o>></c->
    <c- n>uninitialized_relocate_n</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>Size</c-> <c- n>n</c-><c- p>,</c-> <c- n>ForwardIterator</c-> <c- n>result</c-><c- p>);</c->
</pre> <p><em>Effects:</em> Equivalent to:</p> <pre class="highlight"><c- k>for</c-> <c- p>(;</c-> <c- n>n</c-> <c- o>></c-> <c- mi>0</c-><c- p>;</c-> <c- o>++</c-><c- n>result</c-><c- p>,</c-> <c- p>(</c-><c- b>void</c-><c- p>)</c-> <c- o>++</c-><c- n>first</c-><c- p>,</c-> <c- o>--</c-><c- n>n</c-><c- p>)</c-> <c- p>{</c->
  <c- o>::</c-><c- k>new</c-> <c- p>(</c-><c- k>static_cast</c-><c- o>&lt;</c-><c- b>void</c-><c- o>*></c-><c- p>(</c-><c- n>addressof</c-><c- p>(</c-><c- o>*</c-><c- n>result</c-><c- p>)))</c->
    <c- k>typename</c-> <c- n>iterator_traits</c-><c- o>&lt;</c-><c- n>ForwardIterator</c-><c- o>>::</c-><c- n>value_type</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- o>*</c-><c- n>first</c-><c- p>));</c->
  <c- n>destroy_at</c-><c- p>(</c-><c- n>addressof</c-><c- p>(</c-><c- o>*</c-><c- n>first</c-><c- p>));</c->
<c- p>}</c->
<c- k>return</c-> <c- p>{</c-><c- n>first</c-><c- p>,</c-><c- n>result</c-><c- p>};</c->
</pre></small>
   </blockquote>
   <h3 class="heading settled" data-level="4.4" id="wording-inheritance"><span class="secno">4.4. </span><span class="content">Trivially relocatable type</span><a class="self-link" href="#wording-inheritance"></a></h3>
   <p>Add a new section in <a href="http://eel.is/c++draft/basic.types">[basic.types]</a>:</p>
   <p><small></small></p>
   <blockquote><small> A move-constructible, destructible object type <code class="highlight"><c- n>T</c-></code> is a <dfn class="dfn-paneled" data-dfn-type="abstract-op" data-export id="abstract-opdef-trivially-relocatable">trivially relocatable</dfn> type if it is:<p></p> <ul><li data-md><p>a trivially copyable type, or</p> </li><li data-md><p>an array of trivially relocatable type, or</p> </li><li data-md><p>a (possibly cv-qualified) class type declared with the <code class="highlight"><c- p>[[</c-><c- n>trivially_relocatable</c-><c- p>]]</c-></code> attribute, or</p> </li><li data-md><p>a (possibly cv-qualified) class type which:</p> <ul><li data-md><p>has no user-provided move constructors,</p> </li><li data-md><p>either has at least one move constructor or has no user-provided copy constructors,</p> </li><li data-md><p>has no user-provided or deleted destructors,</p> </li><li data-md><p>either is final, or has a final destructor, or has no virtual destructors,</p> </li><li data-md><p>has no virtual base classes,</p> </li><li data-md><p>has no <code class="highlight"><c- k>mutable</c-></code> or <code class="highlight"><c- k>volatile</c-></code> members,</p> </li><li data-md><p>all of whose members are either of reference type or of trivially relocatable type, and</p> </li><li data-md><p>all of whose base classes are trivially relocatable.</p> </li></ul></li></ul> <p>[<em>Note:</em> For a trivially relocatable type, the <a data-link-type="abstract-op" href="#abstract-opdef-relocation-operation" id="ref-for-abstract-opdef-relocation-operation">relocation operation</a> (such as the relocation operations
performed by the library functions <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>swap</c-></code> and <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>vector</c-><c- o>::</c-><c- n>resize</c-></code>) is tantamount
to a simple copy of the underlying bytes. <em>—end note</em>]</p> <p>[<em>Note:</em> It is intended that most standard library types be trivially relocatable types. <em>—end note</em>]</p> </small></blockquote>
   <p class="note" role="note"><span>Note:</span> We could simplify the wording by removing the words "either is final, or has a final destructor, or".
However, this would lead to the compiler’s failing
to identify certain (unrealistic) class types as trivially relocatable, when in fact it has enough
information to infer that they <em>are</em> trivially relocatable in practice. This would leave room for a
"better" implementation beneath ours. I tentatively prefer to optimize for maximum performance over spec simplicity.</p>
   <p class="note" role="note"><span>Note:</span> There is no special treatment for volatile subobjects. Using <code class="highlight"><c- n>memmove</c-></code> on volatile subobjects
can cause tearing of reads and writes. This paper introduces no <em>new</em> issues in this area;
see <a data-link-type="biblio" href="#biblio-subobjects">[Subobjects]</a>. The existing issues with <code class="highlight"><c- k>volatile</c-></code> are addressed narrowly by <a data-link-type="biblio" href="#biblio-p1153r0">[P1153R0]</a> and broadly by <a data-link-type="biblio" href="#biblio-p1152r0">[P1152R0]</a>.</p>
   <p class="note" role="note"><span>Note:</span> There is no special treatment for possibly overlapping subobjects. Using <code class="highlight"><c- n>memmove</c-></code> on possibly overlapping
subobjects can overwrite unrelated objects in the vicinity of the destination. This paper introduces
no <em>new</em> issues in this area; see <a data-link-type="biblio" href="#biblio-subobjects">[Subobjects]</a>.</p>
   <p class="issue" id="issue-f1c9711d"><a class="self-link" href="#issue-f1c9711d"></a> The relevant move constructor, copy constructor, and/or destructor must be public and unambiguous.
We imply this via the words "A move-constructible, destructible object type". However, "move-constructible"
and "destructible" are library concepts, not core language concepts, so maybe it is inappropriate
to use them here.</p>
   <div class="issue" id="issue-b03b0df9">
    <a class="self-link" href="#issue-b03b0df9"></a> Consider the following test cases—<wbr><small> <pre class="language-c++ highlight">    <c- k>struct</c-> <c- n>A</c-> <c- p>{</c->
        <c- k>struct</c-> <c- n>MA</c-> <c- p>{</c->
            <c- n>MA</c-><c- p>(</c-><c- n>MA</c-><c- o>&amp;</c-><c- p>);</c->
            <c- n>MA</c-><c- p>(</c-><c- k>const</c-> <c- n>MA</c-><c- o>&amp;</c-><c- p>)</c-> <c- o>=</c-> <c- k>default</c-><c- p>;</c->
            <c- n>MA</c-><c- p>(</c-><c- n>MA</c-><c- o>&amp;&amp;</c-><c- p>)</c-> <c- o>=</c-> <c- k>default</c-><c- p>;</c->
        <c- p>};</c->
        <c- n>mutable</c-> <c- n>MA</c-> <c- n>ma</c-><c- p>;</c->
        <c- n>A</c-><c- p>(</c-><c- k>const</c-> <c- n>A</c-><c- o>&amp;</c-><c- p>)</c-> <c- o>=</c-> <c- k>default</c-><c- p>;</c->
    <c- p>};</c->
    <c- n>static_assert</c-><c- p>(</c-><c- n>not</c-> <c- n>std</c-><c- o>::</c-><c- n>is_trivially_relocatable_v</c-><c- o>&lt;</c-><c- n>A</c-><c- o>></c-><c- p>);</c->

    <c- k>struct</c-> <c- n>B</c-> <c- p>{</c->
        <c- k>struct</c-> <c- n>MB</c-> <c- p>{</c->
            <c- n>MB</c-><c- p>(</c-><c- k>const</c-> <c- k>volatile</c-> <c- n>MB</c-><c- o>&amp;</c-><c- p>);</c->
            <c- n>MB</c-><c- p>(</c-><c- k>const</c-> <c- n>MB</c-><c- o>&amp;</c-><c- p>)</c-> <c- o>=</c-> <c- k>default</c-><c- p>;</c->
            <c- n>MB</c-><c- p>(</c-><c- n>MB</c-><c- o>&amp;&amp;</c-><c- p>)</c-> <c- o>=</c-> <c- k>default</c-><c- p>;</c->
        <c- p>};</c->
        <c- k>volatile</c-> <c- n>MB</c-> <c- n>mb</c-><c- p>;</c->
        <c- n>B</c-><c- p>(</c-><c- k>const</c-> <c- n>B</c-><c- o>&amp;</c-><c- p>)</c-> <c- o>=</c-> <c- k>default</c-><c- p>;</c->
    <c- p>};</c->
    <c- n>static_assert</c-><c- p>(</c-><c- n>not</c-> <c- n>std</c-><c- o>::</c-><c- n>is_trivially_relocatable_v</c-><c- o>&lt;</c-><c- n>B</c-><c- o>></c-><c- p>);</c->

    <c- k>struct</c-> <c- p>[[</c-><c- n>trivially_relocatable</c-><c- p>]]</c-> <c- n>I</c-> <c- p>{</c->
        <c- n>I</c-><c- p>(</c-><c- n>I</c-><c- o>&amp;&amp;</c-><c- p>);</c->
    <c- p>};</c->
    <c- k>struct</c-> <c- nl>J</c-> <c- p>:</c-> <c- n>I</c-> <c- p>{</c->
        <c- n>J</c-><c- p>(</c-><c- k>const</c-> <c- n>J</c-><c- o>&amp;</c-><c- p>);</c->
        <c- n>J</c-><c- p>(</c-><c- n>J</c-><c- o>&amp;&amp;</c-><c- p>)</c-> <c- o>=</c-> <c- k>default</c-><c- p>;</c->
    <c- p>};</c->
    <c- n>static_assert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>is_trivially_relocatable_v</c-><c- o>&lt;</c-><c- n>J</c-><c- o>></c-><c- p>);</c->
</pre></small> We <em>must</em> find a rule that makes neither <code class="highlight"><c- n>A</c-></code> nor <code class="highlight"><c- n>B</c-></code> trivially relocatable,
because the move-construction <code class="highlight"><c- n>A</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>a</c-><c- p>))</c-></code> invokes user-provided copy constructor <code class="highlight"><c- n>MA</c-><c- p>(</c-><c- n>MA</c-><c- o>&amp;</c-><c- p>)</c-></code> and the move-construction <code class="highlight"><c- n>B</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>b</c-><c- p>))</c-></code> invokes user-provided copy constructor <code class="highlight"><c- n>MB</c-><c- p>(</c-><c- k>const</c-> <c- k>volatile</c-> <c- n>MB</c-><c- o>&amp;</c-><c- p>)</c-></code>. 
    <p>We would <em>like</em> to find a rule that makes <code class="highlight"><c- n>J</c-></code> trivially relocatable,
because the <code class="highlight"><c- nl>J</c-> <c- p>:</c-> <c- n>I</c-></code> pattern is used to implement "conditionally trivial relocatability"
for all allocator-aware containers in my libc++ reference implementation.
(The move-constructor and destructor of <code class="highlight"><c- n>J</c-></code> are moved into a base class template <code class="highlight"><c- n>I</c-></code> which is conditionally marked with <code class="highlight"><c- p>[[</c-><c- n>trivially_relocatable</c-><c- p>]]</c-></code>. The copy constructor,
assignment operators, etc. are not moved into the base class because they are not
expected to interfere with trivial relocatability.)
If the <code class="highlight"><c- p>[[</c-><c- n>trivially_relocatable</c-><c- p>]]</c-></code> attribute were modified to take a boolean parameter,
we might not care about this <code class="highlight"><c- n>J</c-></code> example.</p>
   </div>
   <h3 class="heading settled" data-level="4.5" id="wording-attribute"><span class="secno">4.5. </span><span class="content"><code class="highlight"><c- p>[[</c-><c- n>trivially_relocatable</c-><c- p>]]</c-></code> attribute</span><a class="self-link" href="#wording-attribute"></a></h3>
   <p>Add a new section after <a href="http://eel.is/c++draft/dcl.attr.nouniqueaddr">[dcl.attr.nouniqueattr]</a>:</p>
   <p><small></small></p>
   <blockquote><small> The <em>attribute-token</em> <code class="highlight"><c- n>trivially_relocatable</c-></code> specifies that a class type’s relocation operation has no
visible side-effects other than a copy of the underlying bytes, as if by the library function <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>memcpy</c-></code>.
It shall appear at most once in each <em>attribute-list</em> and no <em>attribute-argument-clause</em> shall be present.
It may be applied to the declaration of a class.
The first declaration of a type shall specify the <code class="highlight"><c- n>trivially_relocatable</c-></code> attribute if any declaration of that type
specifies the <code class="highlight"><c- n>trivially_relocatable</c-></code> attribute.
If a type is declared with the <code class="highlight"><c- n>trivially_relocatable</c-></code> attribute in one translation unit and the
same type is declared without the <code class="highlight"><c- n>trivially_relocatable</c-></code> attribute in another translation unit,
the program is ill-formed, no diagnostic required.<p></p> <p>If a type <code class="highlight"><c- n>T</c-></code> is declared with the <code class="highlight"><c- n>trivially_relocatable</c-></code> attribute, and <code class="highlight"><c- n>T</c-></code> is either not move-constructible
or not destructible, the program is ill-formed.</p> <p>If a class type is declared with the <code class="highlight"><c- n>trivially_relocatable</c-></code> attribute, the implementation may replace
relocation operations involving that type (such as those performed by the library functions <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>swap</c-></code> and <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>vector</c-><c- o>::</c-><c- n>resize</c-></code>) with simple copies of the underlying bytes.</p> <p>If a class type is declared with the <code class="highlight"><c- n>trivially_relocatable</c-></code> attribute, and the program relies on
observable side-effects of relocation other than a copy of the underlying bytes, the behavior is undefined.</p> </small></blockquote>
   <p class="issue" id="issue-20b76dab"><a class="self-link" href="#issue-20b76dab"></a> "If a type <code class="highlight"><c- n>T</c-></code> is declared with the <code class="highlight"><c- n>trivially_relocatable</c-></code> attribute, and <code class="highlight"><c- n>T</c-></code> is either not move-constructible
or not destructible, the program is ill-formed." We might want to replace this wording with
a mere "Note" <em>encouraging</em> implementations to diagnose.
See <a href="https://p1144.godbolt.org/z/ociAVX">this example</a> where a diagnostic might be unwanted.</p>
   <h3 class="heading settled" data-level="4.6" id="wording-traits"><span class="secno">4.6. </span><span class="content">Type traits <code class="highlight"><c- n>is_relocatable</c-></code> etc.</span><a class="self-link" href="#wording-traits"></a></h3>
   <p>Add new entries to Table 46 in <a href="http://eel.is/c++draft/meta.unary.prop">[meta.unary.prop]</a>:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <table> <tbody><tr><th>Template</th><th>Condition</th><th>Preconditions</th></tr> <tr> <td><code class="highlight"><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>T</c-><c- o>></c-> <c- k>struct</c-> <c- n>is_relocatable</c-><c- p>;</c-></code></td> <td><code class="highlight"><c- n>is_move_constructible_v</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-></code> is <code class="highlight">true</code> and <code class="highlight"><c- n>is_destructible_v</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-></code> is <code class="highlight">true</code></td> <td>T shall be a complete type, <i>cv</i> <code class="highlight"><c- b>void</c-></code>, or an array of unknown bound.</td> </tr> <tr> <td><code class="highlight"><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>T</c-><c- o>></c-> <c- k>struct</c-> <c- n>is_nothrow_relocatable</c-><c- p>;</c-></code></td> <td><code class="highlight"><c- n>is_relocatable_v</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-></code> is <code class="highlight">true</code> and both the indicated move-constructor and the destructor are known not to throw any exceptions.</td> <td>T shall be a complete type, <i>cv</i> <code class="highlight"><c- b>void</c-></code>, or an array of unknown bound.</td> </tr> <tr> <td><code class="highlight"><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>T</c-><c- o>></c-> <c- k>struct</c-> <c- n>is_trivially_relocatable</c-><c- p>;</c-></code></td> <td><code class="highlight"><c- n>T</c-></code> is a <a data-link-type="abstract-op" href="#abstract-opdef-trivially-relocatable" id="ref-for-abstract-opdef-trivially-relocatable①">trivially relocatable</a> type.</td> <td>T shall be a complete type, <i>cv</i> <code class="highlight"><c- b>void</c-></code>, or an array of unknown bound.</td> </tr> </tbody></table> </small>
   </blockquote>
   <h3 class="heading settled" data-level="4.7" id="wording-concept"><span class="secno">4.7. </span><span class="content"><code class="highlight"><c- n>Relocatable</c-></code> concept</span><a class="self-link" href="#wording-concept"></a></h3>
   <p>Add a new section after <a href="http://eel.is/c++draft/concept.moveconstructible">[concept.moveconstructible]</a>:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>T</c-><c- o>></c->
  <c- n>concept</c-> <c- n>Relocatable</c-> <c- o>=</c-> <c- n>MoveConstructible</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-> <c- o>&amp;&amp;</c-> <c- n>Destructible</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-><c- p>;</c->
</pre> <p><em>Note:</em> This concept is exactly equivalent to <code class="highlight"><c- n>MoveConstructible</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-></code>.</p> </small>
   </blockquote>
   <h2 class="heading settled" data-level="5" id="further"><span class="secno">5. </span><span class="content">Further considerations and directions</span><a class="self-link" href="#further"></a></h2>
   <h3 class="heading settled" data-level="5.1" id="trivially-swappable"><span class="secno">5.1. </span><span class="content">Trivially swappable types</span><a class="self-link" href="#trivially-swappable"></a></h3>
   <p><a data-link-type="biblio" href="#biblio-wang">Mingxin Wang has proposed</a> that "swap"
could be expressed in terms of "relocate". <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>swap</c-></code> today is
typically implemented in terms of one move-construction, two move-assignments,
and one destruction; but there is nothing in the Standard that prevents a library
vendor from implementing it as three relocations, which in the trivially-relocatable
case (the usual case for most types) could be optimized into three calls to <code class="highlight"><c- n>memcpy</c-></code>.</p>
   <p>For reasons <a data-link-type="biblio" href="#biblio-sane">described elsewhere</a>, it seems reasonable
to claim that move-assignment must always "do the sane thing," and therefore we
might propose to define <small></small></p>
   <small> <pre class="language-c++ highlight"><c- n>template</c-><c- o>&lt;</c-><c- n>class</c-> <c- n>T</c-><c- o>></c->
<c- k>struct</c-> <c- nl>is_trivially_swappable</c-> <c- p>:</c-> <c- n>bool_constant</c-><c- o>&lt;</c->
    <c- n>is_trivially_relocatable_v</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-> <c- o>&amp;&amp;</c->
    <c- n>is_move_assignable_v</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c->
<c- o>></c-> <c- p>{};</c->
</pre></small> thus completing the currently-incomplete trio with <code class="highlight"><c- n>is_swappable</c-></code> and <code class="highlight"><c- n>is_nothrow_swappable</c-></code>. 
   <p>However, we do not propose "trivially swappable" at the present time.
It can easily be added in a later paper.</p>
   <h3 class="heading settled" data-level="5.2" id="hetero"><span class="secno">5.2. </span><span class="content">Heterogeneous relocation</span><a class="self-link" href="#hetero"></a></h3>
   <p>Consider that <code class="highlight"><c- n>is_relocatable_v</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-></code> means <code class="highlight"><c- n>is_constructible_v</c-><c- o>&lt;</c-><c- n>T</c-><c- p>,</c-><c- n>T</c-><c- o>&amp;&amp;></c-> <c- n>and</c-> <c- n>is_destructible_v</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-></code>.
We have access to a heterogeneous <code class="highlight"><c- n>is_constructible</c-><c- o>&lt;</c-><c- n>T</c-><c- p>,</c-> <c- n>Us</c-><c- p>...</c-><c- o>></c-></code>.
Should we add a heterogeneous <code class="highlight"><c- n>is_relocatable_from</c-><c- o>&lt;</c-><c- n>T</c-><c- p>,</c-> <c- n>U</c-><c- o>></c-></code>?</p>
   <p>Notice that <code class="highlight"><c- n>uninitialized_copy</c-></code> and <code class="highlight"><c- n>uninitialized_move</c-></code> are already heterogeneous.
Here is what a heterogeneous <code class="highlight"><c- n>uninitialized_relocate</c-></code> would look like.</p>
   <p><small></small></p>
   <small> <pre class="language-c++ highlight"><c- n>template</c-><c- o>&lt;</c-><c- n>class</c-> <c- n>FwdIt</c-><c- p>,</c-> <c- n>class</c-> <c- n>OutIt</c-><c- o>></c->
<c- b>void</c-> <c- n>uninitialized_relocate</c-><c- p>(</c-><c- n>FwdIt</c-> <c- n>first</c-><c- p>,</c-> <c- n>FwdIt</c-> <c- n>last</c-><c- p>,</c-> <c- n>OutIt</c-> <c- n>d_first</c-><c- p>)</c-> <c- p>{</c->
    <c- n>using</c-> <c- n>SrcT</c-> <c- o>=</c-> <c- n>remove_cvref_t</c-><c- o>&lt;</c-><c- n>decltype</c-><c- p>(</c-><c- o>*</c-><c- n>first</c-><c- p>)</c-><c- o>></c-><c- p>;</c->
    <c- n>using</c-> <c- n>DstT</c-> <c- o>=</c-> <c- n>remove_cvref_t</c-><c- o>&lt;</c-><c- n>decltype</c-><c- p>(</c-><c- o>*</c-><c- n>d_first</c-><c- p>)</c-><c- o>></c-><c- p>;</c->
    <c- n>static_assert</c-><c- p>(</c-><c- n>is_relocatable_from_v</c-><c- o>&lt;</c-><c- n>DstT</c-><c- p>,</c-> <c- n>SrcT</c-><c- o>></c-><c- p>);</c->
    <c- k>if</c-> <c- nf>constexpr</c-> <c- p>(</c-><c- n>is_trivially_relocatable_from_v</c-><c- o>&lt;</c-><c- n>DstT</c-><c- p>,</c-> <c- n>SrcT</c-><c- o>></c-><c- p>)</c-> <c- p>{</c->
        <c- n>static_assert</c-><c- p>(</c-><c- k>sizeof</c-> <c- p>(</c-><c- n>SrcT</c-><c- p>)</c-> <c- o>==</c-> <c- k>sizeof</c-><c- p>(</c-><c- n>DstT</c-><c- p>));</c->
        <c- k>if</c-> <c- n>constexpr</c-> <c- p>(</c-><c- n>is_pointer_v</c-><c- o>&lt;</c-><c- n>FwdIt</c-><c- o>></c-> <c- o>&amp;&amp;</c-> <c- n>is_pointer_v</c-><c- o>&lt;</c-><c- n>OutIt</c-><c- o>></c-><c- p>)</c-> <c- p>{</c->
            <c- c1>// Trivial relocation + contiguous iterators = memcpy</c->
            <c- b>size_t</c-> <c- n>n</c-> <c- o>=</c-> <c- n>last</c-> <c- o>-</c-> <c- n>first</c-><c- p>;</c->
            <c- k>if</c-> <c- p>(</c-><c- n>n</c-><c- p>)</c-> <c- n>memcpy</c-><c- p>(</c-><c- n>d_first</c-><c- p>,</c-> <c- n>first</c-><c- p>,</c-> <c- n>n</c-> <c- o>*</c-> <c- k>sizeof</c-> <c- p>(</c-><c- n>SrcT</c-><c- p>));</c->
            <c- n>d_first</c-> <c- o>+=</c-> <c- n>n</c-><c- p>;</c->
        <c- p>}</c-> <c- k>else</c-> <c- p>{</c->
            <c- k>while</c-> <c- p>(</c-><c- n>first</c-> <c- o>!=</c-> <c- n>last</c-><c- p>)</c-> <c- p>{</c->
                <c- n>memcpy</c-><c- p>(</c-><c- n>addressof</c-><c- p>(</c-><c- o>*</c-><c- n>d_first</c-><c- p>),</c-> <c- n>addressof</c-><c- p>(</c-><c- o>*</c-><c- n>first</c-><c- p>),</c-> <c- k>sizeof</c-> <c- p>(</c-><c- n>SrcT</c-><c- p>));</c->
                <c- o>++</c-><c- n>d_first</c-><c- p>;</c-> <c- o>++</c-><c- n>first</c-><c- p>;</c->
            <c- p>}</c->
        <c- p>}</c->
    <c- p>}</c-> <c- k>else</c-> <c- p>{</c->
        <c- k>while</c-> <c- p>(</c-><c- n>first</c-> <c- o>!=</c-> <c- n>last</c-><c- p>)</c-> <c- p>{</c->
            <c- o>::</c-><c- n>new</c-> <c- p>((</c-><c- b>void</c-><c- o>*</c-><c- p>)</c-><c- n>addressof</c-><c- p>(</c-><c- o>*</c-><c- n>d_first</c-><c- p>))</c-> <c- n>DstT</c-><c- p>(</c-><c- n>move</c-><c- p>(</c-><c- o>*</c-><c- n>first</c-><c- p>));</c->
            <c- p>(</c-><c- o>*</c-><c- n>first</c-><c- p>).</c-><c- o>~</c-><c- n>SrcT</c-><c- p>();</c->
            <c- o>++</c-><c- n>d_first</c-><c- p>;</c-> <c- o>++</c-><c- n>first</c-><c- p>;</c->
        <c- p>}</c->
    <c- p>}</c->
    <c- k>return</c-> <c- n>d_first</c-><c- p>;</c->
<c- p>}</c->
</pre></small> 
   <p>This implementation could be used to quickly relocate an array of <code class="highlight"><c- b>int</c-><c- o>*</c-></code> into an array of <code class="highlight"><c- n>unique_ptr</c-><c- o>&lt;</c-><c- b>int</c-><c- o>></c-></code> (but not vice versa).
All we’d need is for somebody to set the value of <code class="highlight"><c- n>is_trivially_relocatable_from</c-></code> appropriately for each pair of types in the program.</p>
   <p>I think this is a very intriguing idea. The detection syntax (<code class="highlight"><c- n>is_trivially_relocatable_from</c-></code>)
is fairly obvious. But I don’t see what the opt-in syntax
would look like on a program-defined class such as <code class="highlight"><c- n>tombstone</c-><c- o>::</c-><c- n>optional</c-></code>.
Let’s leave that problem alone for a few years and see what develops.</p>
   <p>We could conceivably provide the detection trait today,
with deliberately curtailed semantics, e.g.:</p>
   <p><small></small></p>
   <small> <pre class="language-c++ highlight">    <c- n>template</c-><c- o>&lt;</c-><c- n>class</c-> <c- n>T</c-><c- p>,</c-> <c- n>class</c-> <c- n>U</c-><c- o>></c->
    <c- k>struct</c-> <c- nl>is_trivially_relocatable_from</c-> <c- p>:</c-> <c- n>bool_constant</c-><c- o>&lt;</c->
        <c- n>is_trivially_relocatable_v</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-> <c- n>and</c->
        <c- n>is_same_v</c-><c- o>&lt;</c-><c- n>U</c-><c- p>,</c-> <c- n>remove_cvref_t</c-><c- o>&lt;</c-><c- n>T</c-><c- o>>></c->
    <c- o>></c-> <c- p>{};</c->
    <c- n>template</c-><c- o>&lt;</c-><c- n>class</c-> <c- n>T</c-><c- p>,</c-> <c- n>class</c-> <c- n>U</c-><c- o>></c->
    <c- k>struct</c-> <c- n>is_trivially_relocatable_from</c-><c- o>&lt;</c-><c- n>T</c-><c- p>,</c-> <c- n>U</c-><c- o>&amp;></c-> <c- o>:</c-> <c- n>is_trivially_relocatable_from</c-><c- o>&lt;</c-><c- n>T</c-><c- p>,</c-> <c- n>U</c-><c- o>></c-> <c- p>{};</c->
    <c- n>template</c-><c- o>&lt;</c-><c- n>class</c-> <c- n>T</c-><c- p>,</c-> <c- n>class</c-> <c- n>U</c-><c- o>></c->
    <c- k>struct</c-> <c- n>is_trivially_relocatable_from</c-><c- o>&lt;</c-><c- n>T</c-><c- p>,</c-> <c- n>U</c-><c- o>&amp;&amp;></c-> <c- o>:</c-> <c- n>is_trivially_relocatable_from</c-><c- o>&lt;</c-><c- n>T</c-><c- p>,</c-> <c- n>U</c-><c- o>></c-> <c- p>{};</c->
</pre></small> 
   <p>plus permission for vendors to extend the trait via partial specializations on
a QoI basis:</p>
   <p><small></small></p>
   <small> <pre class="language-c++ highlight">    <c- n>template</c-><c- o>&lt;</c-><c- n>class</c-> <c- n>T</c-><c- o>></c->
    <c- k>struct</c-> <c- n>is_trivially_relocatable_from</c-><c- o>&lt;</c-><c- n>unique_ptr</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-><c- p>,</c-> <c- n>T</c-><c- o>*></c-> <c- o>:</c-> <c- n>true_type</c-> <c- p>{};</c->
    <c- n>template</c-><c- o>&lt;</c-><c- n>class</c-> <c- n>T</c-><c- o>></c->
    <c- k>struct</c-> <c- n>is_trivially_relocatable_from</c-><c- o>&lt;</c-><c- k>const</c-> <c- n>T</c-><c- o>*</c-><c- p>,</c-> <c- n>T</c-><c- o>*></c-> <c- o>:</c-> <c- n>true_type</c-> <c- p>{};</c->
    <c- k>struct</c-> <c- n>is_trivially_relocatable_from</c-><c- o>&lt;</c-><c- b>int</c-><c- p>,</c-> <c- b>unsigned</c-><c- o>></c-> <c- o>:</c-> <c- n>true_type</c-> <c- p>{};</c->
    <c- c1>// and so on</c->
</pre></small> 
   <p>However, if we do this, we may soon find that programmers are adding specializations
of <code class="highlight"><c- n>is_trivially_relocatable_from</c-></code> to their own programs, because they find it
makes their code run faster. It will become a de-facto customization point, and we will
never be able to "fix it right" for fear of breaking programmers' existing code.</p>
   <p>Therefore, I believe that we should <em>not</em> pursue "heterogeneous" relocation
operations in C++20.</p>
   <p>Note that vendors are already free to optimize heterogeneous operations inside
library algorithms, under the as-if rule. We lack a portable and generic detection
trait, but vendors are presumably well aware of specific special cases that they <em>could</em> detect and optimize today —<wbr>for example, a <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>copy</c-></code> from an array of <code class="highlight"><c- b>int</c-><c- o>*</c-></code> into
an array of <code class="highlight"><c- k>const</c-> <c- b>int</c-><c- o>*</c-></code>, or from an array of 64-bit <code class="highlight"><c- b>long</c-></code> into
an array of 64-bit <code class="highlight"><c- b>long</c-> <c- b>long</c-></code> (see <a data-link-type="biblio" href="#biblio-tcf">[TCF]</a>).
Today vendors generally choose not to perform these optimizations.</p>
   <h2 class="heading settled" data-level="6" id="acknowledgements"><span class="secno">6. </span><span class="content">Acknowledgements</span><a class="self-link" href="#acknowledgements"></a></h2>
   <p>Thanks to Elias Kosunen, Niall Douglas, and John Bandela for their feedback on early drafts of this paper.</p>
   <p>Many thanks to Matt Godbolt for allowing me to install the prototype Clang implementation on Compiler Explorer
(<a href="https://p1144.godbolt.org/z/oWEd_X">godbolt.org</a>). See also <a data-link-type="biblio" href="#biblio-announcing">[Announcing]</a>.</p>
   <p>Thanks to Nicolas Lesser for his relentless feedback on drafts of this paper, and for his helpful
review comments on the Clang implementation.</p>
   <p>Thanks to Howard Hinnant for appearing with me on <a data-link-type="biblio" href="#biblio-cppchat">[CppChat]</a>, and to Jon Kalb and Phil Nash for hosting us.</p>
   <p>Thanks to Pablo Halpern for <a data-link-type="biblio" href="#biblio-n4158">[N4158]</a>, to which this paper bears a striking and coincidental resemblance —<wbr>including the meaning assigned to the word "trivial," and the library-algorithm approach to avoiding the
problems with "lame duck objects" discussed in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm#Alternative%20move%20designs">the final section</a> of <a data-link-type="biblio" href="#biblio-n1377">[N1377]</a>. See <a href="http://wiki.edg.com/bin/view/Wg21rapperswil2014/N4034">discussion of N4034 at Rapperswil</a> (June 2014)
and <a href="http://wiki.edg.com/bin/view/Wg21urbana-champaign/EvolutionWorkingGroup#N4158_Destructive_Move_Rev_1">discussion
of N4158 at Urbana</a> (November 2014).</p>
   <p>The term "relocation" is due to <a data-link-type="biblio" href="#biblio-eastl">[EASTL]</a> (<code class="highlight"><c- n>has_trivial_relocate</c-></code>) and <a data-link-type="biblio" href="#biblio-folly">[Folly]</a> (<code class="highlight"><c- n>IsRelocatable</c-></code>). The same concept
appears in pre-C++11 libraries under the name "movable": Qt (<code class="highlight"><c- n>Q_MOVABLE_TYPE</c-></code>) and BSL (<code class="highlight"><c- n>IsBitwiseMoveable</c-></code>).
The same concept also appears in <a data-link-type="biblio" href="#biblio-swift">[Swift]</a> as "<i>bitwise movable</i>."</p>
   <p>Significantly different approaches to this problem have previously appeared in Rodrigo Castro Campos’s <a data-link-type="biblio" href="#biblio-n2754">[N2754]</a>, Denis Bider’s <a data-link-type="biblio" href="#biblio-p0023r0">[P0023R0]</a> (introducing a core-language "relocation" operator), and
Niall Douglas’s <a data-link-type="biblio" href="#biblio-p1029r0">[P1029R0]</a> (treating relocatability as an aspect of move-construction in isolation,
rather than an aspect of the class type as a whole).</p>
   <h2 class="heading settled" id="polls"><span class="content">Appendix A: Straw polls</span><a class="self-link" href="#polls"></a></h2>
   <h3 class="heading settled" id="taken-polls"><span class="content">Polls taken of SG14 on 2018-09-26</span><a class="self-link" href="#taken-polls"></a></h3>
   <table class="def">
    <tbody>
     <tr>
      <th style="width: 70%;">
      <th><strong>SF</strong>
      <th><strong>F</strong>
      <th><strong>N</strong>
      <th><strong>A</strong>
      <th><strong>SA</strong>
     <tr>
      <th><small>The type trait <code class="highlight"><c- n>is_trivially_relocatable</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-></code> (and its <code class="highlight"><c- n>_v</c-></code> version) should be added to the <code class="highlight"><c- o>&lt;</c-><c- n>type_traits</c-><c- o>></c-></code> header, under that exact name, as proposed in this paper.</small>
      <th> 1 
      <th> 20 
      <th> 7 
      <th> 1 
      <th> 0 
     <tr>
      <th><small>We approve of a trait with the semantics of <code class="highlight"><c- n>is_trivially_relocatable</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-></code>, but not necessarily under that exact name. (For example, <code class="highlight"><c- n>is_bitwise_relocatable</c-></code>.)</small>
      <th> 15 
      <th> 12 
      <th> 1 
      <th> 0 
      <th> 0 
     <tr>
      <th><small>We approve of the general idea that user-defined classes should be able to warrant their own trivial relocatability.</small>
      <th> 25 
      <th> 5 
      <th> 2 
      <th> 0 
      <th> 0 
   </table>
   <h3 class="heading settled" id="lewg-polls"><span class="content">Polls requested of LEWG in San Diego</span><a class="self-link" href="#lewg-polls"></a></h3>
   <table class="def">
    <tbody>
     <tr>
      <th style="width: 70%;">
      <th><strong>SF</strong>
      <th><strong>F</strong>
      <th><strong>N</strong>
      <th><strong>A</strong>
      <th><strong>SA</strong>
     <tr>
      <th><small>The algorithm <code class="highlight"><c- n>uninitialized_relocate</c-><c- p>(</c-><c- n>first</c-><c- p>,</c-> <c- n>last</c-><c- p>,</c-> <c- n>d_first</c-><c- p>)</c-></code> should be added to the <code class="highlight"><c- o>&lt;</c-><c- n>memory</c-><c- o>></c-></code> header,
as proposed in this paper.</small>
      <th>(_)
      <th>_
      <th>_
      <th>_
      <th>_
     <tr>
      <th><small>The type trait <code class="highlight"><c- n>is_relocatable</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-></code> (and its <code class="highlight"><c- n>_v</c-></code> version) should be added to the <code class="highlight"><c- o>&lt;</c-><c- n>type_traits</c-><c- o>></c-></code> header, as proposed in this paper.</small>
      <th>(_)
      <th>_
      <th>_
      <th>_
      <th>_
     <tr>
      <th><small>If <code class="highlight"><c- n>is_relocatable</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-></code> <em>is</em> added, then we should also add <code class="highlight"><c- n>is_nothrow_relocatable</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-></code> (and its <code class="highlight"><c- n>_v</c-></code> version), as proposed in this paper.</small>
      <th>(_)
      <th>_
      <th>_
      <th>_
      <th>_
     <tr>
      <th><small>The type trait <code class="highlight"><c- n>is_trivially_relocatable</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-></code> (and its <code class="highlight"><c- n>_v</c-></code> version) should be added to the <code class="highlight"><c- o>&lt;</c-><c- n>type_traits</c-><c- o>></c-></code> header, under that exact name, as proposed in this paper.</small>
      <th>(_)
      <th>_
      <th>_
      <th>_
      <th>_
     <tr>
      <th><small>We approve of a trait with the semantics of <code class="highlight"><c- n>is_trivially_relocatable</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-></code>, but not necessarily under that exact name. (For example, <code class="highlight"><c- n>is_bitwise_relocatable</c-></code>.)</small>
      <th>(_)
      <th>_
      <th>_
      <th>_
      <th>_
     <tr>
      <th><small>If <code class="highlight"><c- n>is_trivially_relocatable</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-></code> <em>is</em> added, under that exact name, then the type trait <code class="highlight"><c- n>is_trivially_swappable</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-></code> (and its <code class="highlight"><c- n>_v</c-></code> version) should also be added to the <code class="highlight"><c- o>&lt;</c-><c- n>type_traits</c-><c- o>></c-></code> header.</small>
      <th>_
      <th>_
      <th>(_)
      <th>_
      <th>_
   </table>
   <h3 class="heading settled" id="ewg-polls"><span class="content">Polls requested of EWG in San Diego</span><a class="self-link" href="#ewg-polls"></a></h3>
   <table class="def">
    <tbody>
     <tr>
      <th style="width: 70%;">
      <th><strong>SF</strong>
      <th><strong>F</strong>
      <th><strong>N</strong>
      <th><strong>A</strong>
      <th><strong>SA</strong>
     <tr>
      <th><small>We approve of the general idea that user-defined classes should be able to warrant their own trivial relocatability via a standard mechanism.</small>
      <th>(_)
      <th>_
      <th>_
      <th>_
      <th>_
     <tr>
      <th><small>We approve of the general idea that user-defined classes which follow the Rule of Zero should inherit the trivial relocatability of their bases and members.</small>
      <th>(_)
      <th>_
      <th>_
      <th>_
      <th>_
     <tr>
      <th><small>Nobody should be able to warrant the trivial relocatability of <code class="highlight"><c- k>class</c-> <c- nc>C</c-></code> except for <code class="highlight"><c- k>class</c-> <c- nc>C</c-></code> itself (i.e., we do not want to see a customization point analogous to <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>hash</c-></code>).</small>
      <th>(_)
      <th>_
      <th>_
      <th>_
      <th>_
     <tr>
      <th><small>A class should be able to warrant its own trivial relocatability via the attribute <code class="highlight"><c- p>[[</c-><c- n>trivially_relocatable</c-><c- p>]]</c-></code>, as proposed in this paper.</small>
      <th>(_)
      <th>_
      <th>_
      <th>_
      <th>_
     <tr>
      <th><small>A class should be able to warrant its own trivial relocatability via some attribute, but not necessarily under that exact name.</small>
      <th>(_)
      <th>_
      <th>_
      <th>_
      <th>_
     <tr>
      <th><small>A class should be able to warrant its own trivial relocatability as proposed in this paper, but via a contextual keyword rather than an attribute.</small>
      <th>_
      <th>_
      <th>(_)
      <th>_
      <th>_
     <tr>
      <th><small>If a trait with the semantics of <code class="highlight"><c- n>is_trivially_relocatable</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-></code> is added to the <code class="highlight"><c- o>&lt;</c-><c- n>type_traits</c-><c- o>></c-></code> header, the programmer should be permitted to specialize it for program-defined types (i.e., we want to see that trait itself become a customization point analogous to <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>hash</c-></code>).</small>
      <th>_
      <th>_
      <th>_
      <th>_
      <th>(_)
     <tr>
      <th><small>Trivial relocatability should be assumed by default. Classes such as those in <a href="#non-trivial-samples">Appendix C</a> should indicate their non-trivial relocatability via an opt-in mechanism.</small>
      <th>_
      <th>_
      <th>_
      <th>_
      <th>(_)
     <tr>
      <th><small>To simplify <a href="#sample-conditional">Conditionally trivial relocation</a>, if an attribute with the semantics of <code class="highlight"><c- p>[[</c-><c- n>trivially_relocatable</c-><c- p>]]</c-></code> is added, it should take a boolean argument.</small>
      <th>_
      <th>_
      <th>_
      <th>(_)
      <th>_
   </table>
   <h2 class="heading settled" id="samples"><span class="content">Appendix B: Sample code</span><a class="self-link" href="#samples"></a></h2>
   <h3 class="heading settled" id="sample-deducing"><span class="content">Defining a trivially relocatable function object</span><a class="self-link" href="#sample-deducing"></a></h3>
   <p>The following sample illustrates <a href="#use2">§2.2 Program-defined types that follow the Rule of Zero</a>. Here <code class="highlight"><c- n>A</c-></code> is a program-defined type
following the Rule of Zero. Because all of its bases and members are warranted as
trivially relocatable, and its move-constructor and destructor are both defaulted,
the compiler concludes that <code class="highlight"><c- n>A</c-></code> itself is trivially relocatable.</p>
<pre class="language-c++ highlight">    <c- cp>#include</c-> &lt;string>
    <c- cp>#include</c-> &lt;type_traits>

    <c- c1>// Assume that the library vendor has taken care of this part.</c->
    <c- n>static_assert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>is_trivially_relocatable_v</c-><c- o>&lt;</c-> <c- n>std</c-><c- o>::</c-><c- n>string</c-> <c- o>></c-><c- p>);</c->

    <c- k>struct</c-> <c- n>A</c-> <c- p>{</c->
        <c- n>std</c-><c- o>::</c-><c- n>string</c-> <c- n>s</c-><c- p>;</c->
        <c- n>std</c-><c- o>::</c-><c- n>string</c-> <c- n>operator</c-><c- p>()(</c-><c- n>std</c-><c- o>::</c-><c- n>string</c-> <c- n>t</c-><c- p>)</c-> <c- k>const</c-> <c- p>{</c-> <c- k>return</c-> <c- n>s</c-> <c- o>+</c-> <c- n>t</c-><c- p>;</c-> <c- p>}</c->
    <c- p>};</c->

    <c- n>static_assert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>is_trivially_relocatable_v</c-><c- o>&lt;</c-> <c- n>A</c-> <c- o>></c-><c- p>);</c->
</pre>
   <p>The following sample, involving an implementation-defined closure type,
also illustrates <a href="#use2">§2.2 Program-defined types that follow the Rule of Zero</a>.</p>
<pre class="language-c++ highlight">    <c- cp>#include</c-> &lt;string>
    <c- cp>#include</c-> &lt;type_traits>

    <c- c1>// Assume that the library vendor has taken care of this part.</c->
    <c- n>static_assert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>is_trivially_relocatable_v</c-><c- o>&lt;</c-> <c- n>std</c-><c- o>::</c-><c- n>string</c-> <c- o>></c-><c- p>);</c->

    <c- k>auto</c-> <c- n>a</c-> <c- o>=</c-> <c- p>[</c-><c- n>s</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>string</c-><c- p>(</c-><c- s>"hello"</c-><c- p>)](</c-><c- n>std</c-><c- o>::</c-><c- n>string</c-> <c- n>t</c-><c- p>)</c-> <c- p>{</c->
        <c- k>return</c-> <c- n>s</c-> <c- o>+</c-> <c- n>t</c-><c- p>;</c->
    <c- p>};</c->

    <c- n>static_assert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>is_trivially_relocatable_v</c-><c- o>&lt;</c-> <c- n>decltype</c-><c- p>(</c-><c- n>a</c-><c- p>)</c-> <c- o>></c-><c- p>);</c->
</pre>
   <h3 class="heading settled" id="sample-opting-in"><span class="content">Warranting that a user-defined relocation operation is equivalent to <code class="highlight"><c- n>memcpy</c-></code></span><a class="self-link" href="#sample-opting-in"></a></h3>
   <p>The following sample illustrates <a href="#use3">§2.3 Program-defined types with non-defaulted special members</a>. The rules proposed in this paper ensure
that any type with non-trivial user-defined move and destructor operations will be
considered non-trivially relocatable by default.</p>
<pre class="language-c++ highlight">    <c- cp>#include</c-> &lt;type_traits>

    <c- k>struct</c-> <c- n>C</c-> <c- p>{</c->
        <c- k>const</c-> <c- b>char</c-> <c- o>*</c-><c- n>s</c-> <c- o>=</c-> <c- n>nullptr</c-><c- p>;</c->
        <c- n>C</c-><c- p>(</c-><c- k>const</c-> <c- b>char</c-> <c- o>*</c-><c- n>s</c-><c- p>)</c-> <c- o>:</c-> <c- n>s</c-><c- p>(</c-><c- n>s</c-><c- p>)</c-> <c- p>{}</c->
        <c- n>C</c-><c- p>(</c-><c- n>C</c-><c- o>&amp;&amp;</c-> <c- n>rhs</c-><c- p>)</c-> <c- o>:</c-> <c- n>s</c-><c- p>(</c-><c- n>rhs</c-><c- p>.</c-><c- n>s</c-><c- p>)</c-> <c- p>{</c-> <c- n>rhs</c-><c- p>.</c-><c- n>s</c-> <c- o>=</c-> <c- n>nullptr</c-><c- p>;</c-> <c- p>}</c->
        <c- o>~</c-><c- n>C</c-><c- p>()</c-> <c- p>{</c-> <c- n>delete</c-> <c- n>s</c-><c- p>;</c-> <c- p>}</c->
    <c- p>};</c->

    <c- n>static_assert</c-><c- p>(</c-><c- n>not</c-> <c- n>std</c-><c- o>::</c-><c- n>is_trivially_relocatable_v</c-><c- o>&lt;</c-> <c- n>C</c-> <c- o>></c-><c- p>);</c->

    <c- k>struct</c-> <c- nl>D</c-> <c- p>:</c-> <c- n>C</c-> <c- p>{};</c->

    <c- n>static_assert</c-><c- p>(</c-><c- n>not</c-> <c- n>std</c-><c- o>::</c-><c- n>is_trivially_relocatable_v</c-><c- o>&lt;</c-> <c- n>D</c-> <c- o>></c-><c- p>);</c->
</pre>
   <p>The programmer may apply the <code class="highlight"><c- p>[[</c-><c- n>trivially_relocatable</c-><c- p>]]</c-></code> attribute to override the compiler’s default
behavior and warrant (under penalty of undefined behavior) that this type is in fact trivially relocatable.</p>
<pre class="language-c++ highlight">    <c- cp>#include</c-> &lt;type_traits>

    <c- k>struct</c-> <c- p>[[</c-><c- n>trivially_relocatable</c-><c- p>]]</c-> <c- n>E</c-> <c- p>{</c->
        <c- k>const</c-> <c- b>char</c-> <c- o>*</c-><c- n>s</c-> <c- o>=</c-> <c- n>nullptr</c-><c- p>;</c->
        <c- n>E</c-><c- p>(</c-><c- k>const</c-> <c- b>char</c-> <c- o>*</c-><c- n>s</c-><c- p>)</c-> <c- o>:</c-> <c- n>s</c-><c- p>(</c-><c- n>s</c-><c- p>)</c-> <c- p>{}</c->
        <c- n>E</c-><c- p>(</c-><c- n>E</c-><c- o>&amp;&amp;</c-> <c- n>rhs</c-><c- p>)</c-> <c- o>:</c-> <c- n>s</c-><c- p>(</c-><c- n>rhs</c-><c- p>.</c-><c- n>s</c-><c- p>)</c-> <c- p>{</c-> <c- n>rhs</c-><c- p>.</c-><c- n>s</c-> <c- o>=</c-> <c- n>nullptr</c-><c- p>;</c-> <c- p>}</c->
        <c- o>~</c-><c- n>E</c-><c- p>()</c-> <c- p>{</c-> <c- n>delete</c-> <c- n>s</c-><c- p>;</c-> <c- p>}</c->
    <c- p>};</c->

    <c- n>static_assert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>is_trivially_relocatable_v</c-><c- o>&lt;</c-> <c- n>E</c-> <c- o>></c-><c- p>);</c->

    <c- k>struct</c-> <c- nl>F</c-> <c- p>:</c-> <c- n>E</c-> <c- p>{};</c->

    <c- n>static_assert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>is_trivially_relocatable_v</c-><c- o>&lt;</c-> <c- n>F</c-> <c- o>></c-><c- p>);</c->
</pre>
   <h3 class="heading settled" id="sample-uninit-relocate"><span class="content">Reference implementation of <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>uninitialized_relocate</c-></code></span><a class="self-link" href="#sample-uninit-relocate"></a></h3>
   <p><small></small></p>
   <small> <pre class="language-c++ highlight"><c- n>template</c-><c- o>&lt;</c-><c- n>class</c-> <c- n>InputIterator</c-><c- p>,</c-> <c- n>class</c-> <c- n>ForwardIterator</c-><c- o>></c->
<c- n>ForwardIterator</c-> <c- n>uninitialized_relocate</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c->
                                       <c- n>ForwardIterator</c-> <c- n>result</c-><c- p>)</c->
<c- p>{</c->
    <c- n>using</c-> <c- n>T</c-> <c- o>=</c-> <c- kr>typename</c-> <c- n>iterator_traits</c-><c- o>&lt;</c-><c- n>ForwardIterator</c-><c- o>>::</c-><c- n>value_type</c-><c- p>;</c->
    <c- n>using</c-> <c- n>U</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>remove_ref_t</c-><c- o>&lt;</c-><c- n>decltype</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- o>*</c-><c- n>first</c-><c- p>))</c-><c- o>></c-><c- p>;</c->
    <c- n>constexpr</c-> <c- b>bool</c-> <c- n>memcpyable</c-> <c- o>=</c-> <c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>is_same_v</c-><c- o>&lt;</c-><c- n>T</c-><c- p>,</c-> <c- n>U</c-><c- o>></c-> <c- o>&amp;&amp;</c-> <c- n>std</c-><c- o>::</c-><c- n>is_trivially_relocatable_v</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-><c- p>);</c->
    <c- n>constexpr</c-> <c- b>bool</c-> <c- n>both_contiguous</c-> <c- o>=</c-> <c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>is_pointer_v</c-><c- o>&lt;</c-><c- n>InputIterator</c-><c- o>></c-> <c- o>&amp;&amp;</c-> <c- n>std</c-><c- o>::</c-><c- n>is_pointer_v</c-><c- o>&lt;</c-><c- n>ForwardIterator</c-><c- o>></c-><c- p>);</c->

    <c- k>if</c-> <c- nf>constexpr</c-> <c- p>(</c-><c- n>memcpyable</c-> <c- o>&amp;&amp;</c-> <c- n>both_contiguous</c-><c- p>)</c-> <c- p>{</c->
        <c- n>std</c-><c- o>::</c-><c- b>size_t</c-> <c- n>nbytes</c-> <c- o>=</c-> <c- p>(</c-><c- b>char</c-> <c- o>*</c-><c- p>)</c-><c- n>last</c-> <c- o>-</c-> <c- p>(</c-><c- b>char</c-> <c- o>*</c-><c- p>)</c-><c- n>first</c-><c- p>;</c->
        <c- k>if</c-> <c- p>(</c-><c- n>nbytes</c-> <c- o>!=</c-> <c- mi>0</c-><c- p>)</c-> <c- p>{</c->
            <c- n>std</c-><c- o>::</c-><c- n>memmove</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>addressof</c-><c- p>(</c-><c- o>*</c-><c- n>result</c-><c- p>),</c-> <c- n>std</c-><c- o>::</c-><c- n>addressof</c-><c- p>(</c-><c- o>*</c-><c- n>first</c-><c- p>),</c-> <c- n>nbytes</c-><c- p>);</c->
            <c- n>result</c-> <c- o>+=</c-> <c- p>(</c-><c- n>last</c-> <c- o>-</c-> <c- n>first</c-><c- p>);</c->
        <c- p>}</c->
    <c- p>}</c-> <c- k>else</c-> <c- k>if</c-> <c- nf>constexpr</c-> <c- p>(</c-><c- n>memcpyable</c-><c- p>)</c-> <c- p>{</c->
        <c- k>for</c-> <c- p>(;</c-> <c- n>first</c-> <c- o>!=</c-> <c- n>last</c-><c- p>;</c-> <c- p>(</c-><c- b>void</c-><c- p>)</c-><c- o>++</c-><c- n>result</c-><c- p>,</c-> <c- o>++</c-><c- n>first</c-><c- p>)</c-> <c- p>{</c->
            <c- n>std</c-><c- o>::</c-><c- n>memmove</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>addressof</c-><c- p>(</c-><c- o>*</c-><c- n>result</c-><c- p>),</c-> <c- n>std</c-><c- o>::</c-><c- n>addressof</c-><c- p>(</c-><c- o>*</c-><c- n>first</c-><c- p>),</c-> <c- k>sizeof</c-> <c- p>(</c-><c- n>T</c-><c- p>));</c->
        <c- p>}</c->
    <c- p>}</c-> <c- k>else</c-> <c- p>{</c->
        <c- k>for</c-> <c- p>(;</c-> <c- n>first</c-> <c- o>!=</c-> <c- n>last</c-><c- p>;</c-> <c- p>(</c-><c- b>void</c-><c- p>)</c-><c- o>++</c-><c- n>result</c-><c- p>,</c-> <c- o>++</c-><c- n>first</c-><c- p>)</c-> <c- p>{</c->
            <c- o>::</c-><c- n>new</c-> <c- p>(</c-><c- n>static_cast</c-><c- o>&lt;</c-><c- b>void</c-><c- o>*></c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>addressof</c-><c- p>(</c-><c- o>*</c-><c- n>result</c-><c- p>)))</c-> <c- n>T</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- o>*</c-><c- n>first</c-><c- p>));</c->
            <c- n>std</c-><c- o>::</c-><c- n>destroy_at</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>addressof</c-><c- p>(</c-><c- o>*</c-><c- n>first</c-><c- p>));</c->
        <c- p>}</c->
    <c- p>}</c->
    <c- k>return</c-> <c- n>result</c-><c- p>;</c->
<c- p>}</c->
</pre></small> 
   <p>The code in the first branch must use <code class="highlight"><c- n>memmove</c-></code>, rather than <code class="highlight"><c- n>memcpy</c-></code>, to preserve the
formally specified behavior in the case that the source range overlaps the destination range.</p>
   <p>The code in the second branch, which performs one <code class="highlight"><c- n>memmove</c-></code> per element, probably
doesn’t have much of a performance benefit, and might be omitted by library vendors.</p>
   <h3 class="heading settled" id="sample-conditional"><span class="content">Conditionally trivial relocation</span><a class="self-link" href="#sample-conditional"></a></h3>
   <p>We expect, but do not require, that <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>optional</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-></code> should be trivially relocatable
if and only if <code class="highlight"><c- n>T</c-></code> itself is trivially relocatable. We propose no dedicated syntax for conditional <code class="highlight"><c- p>[[</c-><c- n>trivially_relocatable</c-><c- p>]]</c-></code>.</p>
   <p>The following abbreviated implementation shows how to achieve an <code class="highlight"><c- n>optional</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-></code> which
has the same trivial-move-constructibility as <code class="highlight"><c- n>T</c-></code>, the same trivial-destructibility
as <code class="highlight"><c- n>T</c-></code>, and the same trivial-relocatability as <code class="highlight"><c- n>T</c-></code>.</p>
   <p>The primitives of move-construction and destruction are provided by four specializations
of <code class="highlight"><c- n>optional_a</c-></code>; then two specializations of <code class="highlight"><c- n>optional_b</c-></code> extend <code class="highlight"><c- n>optional_a</c-></code> and
either do or do not apply the <code class="highlight"><c- p>[[</c-><c- n>trivially_relocatable</c-><c- p>]]</c-></code> attribute; and finally
the public <code class="highlight"><c- n>optional</c-></code> extends the appropriate specialization of <code class="highlight"><c- n>optional_a</c-></code>.</p>
   <p><small></small></p>
   <small> <pre class="language-c++ highlight"><c- n>template</c-><c- o>&lt;</c-><c- n>class</c-> <c- n>T</c-><c- o>></c->
<c- n>class</c-> <c- nl>optional</c-> <c- p>:</c->
    <c- n>optional_a</c-><c- o>&lt;</c-><c- n>T</c-><c- p>,</c-> <c- n>is_trivially_relocatable_v</c-><c- o>&lt;</c-><c- n>T</c-><c- o>>></c->
<c- p>{</c->
    <c- n>using</c-> <c- n>optional_a</c-><c- o>&lt;</c-><c- n>T</c-><c- p>,</c-> <c- n>is_trivially_relocatable_v</c-><c- o>&lt;</c-><c- n>T</c-><c- o>>>::</c-><c- n>optional_a</c-><c- p>;</c->
<c- p>};</c->

<c- n>template</c-><c- o>&lt;</c-><c- n>class</c-> <c- n>T</c-><c- p>,</c-> <c- b>bool</c-> <c- n>R</c-><c- o>></c->
<c- n>class</c-> <c- nl>optional_a</c-> <c- p>:</c->
    <c- n>optional_b</c-><c- o>&lt;</c-><c- n>T</c-><c- p>,</c-> <c- n>is_trivially_destructible_v</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-><c- p>,</c-> <c- n>is_trivially_move_constructible_v</c-><c- o>&lt;</c-><c- n>T</c-><c- o>>></c->
<c- p>{</c->
    <c- n>using</c-> <c- n>optional_b</c-><c- o>&lt;</c-><c- n>T</c-><c- p>,</c-> <c- n>is_trivially_destructible_v</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-><c- p>,</c->
        <c- n>is_trivially_move_constructible_v</c-><c- o>&lt;</c-><c- n>T</c-><c- o>>>::</c-><c- n>optional_b</c-><c- p>;</c->
<c- p>};</c->

<c- n>template</c-><c- o>&lt;</c-><c- n>class</c-> <c- n>T</c-><c- o>></c->
<c- n>class</c-> <c- p>[[</c-><c- n>trivially_relocatable</c-><c- p>]]</c-> <c- n>optional_a</c-><c- o>&lt;</c-><c- n>T</c-><c- p>,</c-> true<c- o>></c-> <c- o>:</c->
    <c- n>optional_b</c-><c- o>&lt;</c-><c- n>T</c-><c- p>,</c-> <c- n>is_trivially_destructible_v</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-><c- p>,</c-> <c- n>is_trivially_move_constructible_v</c-><c- o>&lt;</c-><c- n>T</c-><c- o>>></c->
<c- p>{</c->
    <c- n>using</c-> <c- n>optional_b</c-><c- o>&lt;</c-><c- n>T</c-><c- p>,</c-> <c- n>is_trivially_destructible_v</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-><c- p>,</c->
        <c- n>is_trivially_move_constructible_v</c-><c- o>&lt;</c-><c- n>T</c-><c- o>>>::</c-><c- n>optional_b</c-><c- p>;</c->
<c- p>};</c->

<c- n>template</c-><c- o>&lt;</c-><c- n>class</c-> <c- n>T</c-><c- p>,</c-> <c- b>bool</c-> <c- n>D</c-><c- p>,</c-> <c- b>bool</c-> <c- n>M</c-><c- o>></c->
<c- n>class</c-> <c- n>optional_b</c-> <c- p>{</c->
    <c- k>union</c-> <c- p>{</c->
        <c- b>char</c-> <c- n>dummy_</c-><c- p>;</c->
        <c- n>T</c-> <c- n>value_</c-><c- p>;</c->
    <c- p>};</c->
    <c- b>bool</c-> <c- n>engaged_</c-> <c- o>=</c-> false<c- p>;</c->

    <c- n>optional_b</c-><c- p>()</c-> <c- o>=</c-> <c- k>default</c-><c- p>;</c->
    <c- n>optional_b</c-><c- p>(</c-><c- n>inplace_t</c-><c- p>,</c-> <c- n>Args</c-><c- o>&amp;&amp;</c-> <c- n>args</c-><c- p>...)</c-> <c- o>:</c->
        <c- n>engaged_</c-><c- p>(</c->true<c- p>),</c-> <c- n>value_</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>Args</c-><c- o>></c-><c- p>(</c-><c- n>args</c-><c- p>)...)</c-> <c- p>{}</c->
    <c- n>optional_b</c-><c- p>(</c-><c- n>optional_b</c-><c- o>&amp;&amp;</c-> <c- n>rhs</c-><c- p>)</c-> <c- p>{</c->
        <c- k>if</c-> <c- p>(</c-><c- n>rhs</c-><c- p>.</c-><c- n>engaged_</c-><c- p>)</c-> <c- p>{</c->
            <c- n>engaged_</c-> <c- o>=</c-> true<c- p>;</c->
            <c- o>::</c-><c- n>new</c-> <c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>addressof</c-><c- p>(</c-><c- n>value_</c-><c- p>))</c-> <c- n>T</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>rhs</c-><c- p>.</c-><c- n>value_</c-><c- p>));</c->
        <c- p>}</c->
    <c- p>}</c->
    <c- o>~</c-><c- n>optional_b</c-><c- p>()</c-> <c- p>{</c->
        <c- k>if</c-> <c- p>(</c-><c- n>engaged_</c-><c- p>)</c-> <c- n>value_</c-><c- p>.</c-><c- o>~</c-><c- n>T</c-><c- p>();</c->
    <c- p>}</c->
<c- p>};</c->

<c- n>template</c-><c- o>&lt;</c-><c- n>class</c-> <c- n>T</c-><c- o>></c->
<c- n>class</c-> <c- n>optional_b</c-><c- o>&lt;</c-><c- n>T</c-><c- p>,</c-> false<c- p>,</c-> true<c- o>></c-> <c- p>{</c->
    <c- k>union</c-> <c- p>{</c->
        <c- b>char</c-> <c- n>dummy_</c-><c- p>;</c->
        <c- n>T</c-> <c- n>value_</c-><c- p>;</c->
    <c- p>};</c->
    <c- b>bool</c-> <c- n>engaged_</c-> <c- o>=</c-> false<c- p>;</c->

    <c- n>optional_b</c-><c- p>()</c-> <c- o>=</c-> <c- k>default</c-><c- p>;</c->
    <c- n>optional_b</c-><c- p>(</c-><c- n>inplace_t</c-><c- p>,</c-> <c- n>Args</c-><c- o>&amp;&amp;</c-> <c- n>args</c-><c- p>...)</c-> <c- o>:</c->
        <c- n>engaged_</c-><c- p>(</c->true<c- p>),</c-> <c- n>value_</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>Args</c-><c- o>></c-><c- p>(</c-><c- n>args</c-><c- p>)...)</c-> <c- p>{}</c->
    <c- n>optional_b</c-><c- p>(</c-><c- n>optional_b</c-><c- o>&amp;&amp;</c-><c- p>)</c-> <c- o>=</c-> <c- k>default</c-><c- p>;</c->
    <c- o>~</c-><c- n>optional_b</c-><c- p>()</c-> <c- p>{</c->
        <c- k>if</c-> <c- p>(</c-><c- n>engaged_</c-><c- p>)</c-> <c- n>value_</c-><c- p>.</c-><c- o>~</c-><c- n>T</c-><c- p>();</c->
    <c- p>}</c->
<c- p>};</c->

<c- n>template</c-><c- o>&lt;</c-><c- n>class</c-> <c- n>T</c-><c- o>></c->
<c- n>class</c-> <c- n>optional_b</c-><c- o>&lt;</c-><c- n>T</c-><c- p>,</c-> true<c- p>,</c-> false<c- o>></c-> <c- p>{</c->
    <c- k>union</c-> <c- p>{</c->
        <c- b>char</c-> <c- n>dummy_</c-><c- p>;</c->
        <c- n>T</c-> <c- n>value_</c-><c- p>;</c->
    <c- p>};</c->
    <c- b>bool</c-> <c- n>engaged_</c-> <c- o>=</c-> false<c- p>;</c->

    <c- n>optional_b</c-><c- p>()</c-> <c- o>=</c-> <c- k>default</c-><c- p>;</c->
    <c- n>optional_b</c-><c- p>(</c-><c- n>inplace_t</c-><c- p>,</c-> <c- n>Args</c-><c- o>&amp;&amp;</c-> <c- n>args</c-><c- p>...)</c-> <c- o>:</c->
        <c- n>engaged_</c-><c- p>(</c->true<c- p>),</c-> <c- n>value_</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>Args</c-><c- o>></c-><c- p>(</c-><c- n>args</c-><c- p>)...)</c-> <c- p>{}</c->
    <c- n>optional_b</c-><c- p>(</c-><c- n>optional_b</c-><c- o>&amp;&amp;</c-> <c- n>rhs</c-><c- p>)</c-> <c- p>{</c->
        <c- k>if</c-> <c- p>(</c-><c- n>rhs</c-><c- p>.</c-><c- n>engaged_</c-><c- p>)</c-> <c- p>{</c->
            <c- n>engaged_</c-> <c- o>=</c-> true<c- p>;</c->
            <c- o>::</c-><c- n>new</c-> <c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>addressof</c-><c- p>(</c-><c- n>value_</c-><c- p>))</c-> <c- n>T</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>rhs</c-><c- p>.</c-><c- n>value_</c-><c- p>));</c->
        <c- p>}</c->
    <c- p>}</c->
    <c- o>~</c-><c- n>optional_b</c-><c- p>()</c-> <c- o>=</c-> <c- k>default</c-><c- p>;</c->
<c- p>};</c->

<c- n>template</c-><c- o>&lt;</c-><c- n>class</c-> <c- n>T</c-><c- o>></c->
<c- n>class</c-> <c- n>optional_b</c-><c- o>&lt;</c-><c- n>T</c-><c- p>,</c-> true<c- p>,</c-> true<c- o>></c-> <c- p>{</c->
    <c- k>union</c-> <c- p>{</c->
        <c- b>char</c-> <c- n>dummy_</c-><c- p>;</c->
        <c- n>T</c-> <c- n>value_</c-><c- p>;</c->
    <c- p>};</c->
    <c- b>bool</c-> <c- n>engaged_</c-> <c- o>=</c-> false<c- p>;</c->

    <c- n>optional_b</c-><c- p>()</c-> <c- o>=</c-> <c- k>default</c-><c- p>;</c->
    <c- n>optional_b</c-><c- p>(</c-><c- n>inplace_t</c-><c- p>,</c-> <c- n>Args</c-><c- o>&amp;&amp;</c-> <c- n>args</c-><c- p>...)</c-> <c- o>:</c->
        <c- n>engaged_</c-><c- p>(</c->true<c- p>),</c-> <c- n>value_</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>Args</c-><c- o>></c-><c- p>(</c-><c- n>args</c-><c- p>)...)</c-> <c- p>{}</c->

    <c- n>optional_b</c-><c- p>(</c-><c- n>optional_b</c-><c- o>&amp;&amp;</c-><c- p>)</c-> <c- o>=</c-> <c- k>default</c-><c- p>;</c->
    <c- o>~</c-><c- n>optional_b</c-><c- p>()</c-> <c- o>=</c-> <c- k>default</c-><c- p>;</c->
<c- p>};</c->
</pre></small> 
   <h2 class="heading settled" id="non-trivial-samples"><span class="content">Appendix C: Examples of non-trivially relocatable class types</span><a class="self-link" href="#non-trivial-samples"></a></h2>
   <h3 class="heading settled" id="non-trivial-sample-string"><span class="content">Class contains pointer to self</span><a class="self-link" href="#non-trivial-sample-string"></a></h3>
   <p>This fictional <code class="highlight"><c- n>short_string</c-></code> illustrates a mechanism that can apply
to any small-buffer-optimized class. <a data-link-type="biblio" href="#biblio-libcxxfunction">libc++'s std::function</a> uses this mechanism (on a 24-byte buffer) and is thus not trivially relocatable.</p>
   <p>However, different mechanisms for small-buffer optimization exist. <a data-link-type="biblio" href="#biblio-libcxxany">libc++'s std::any</a> also achieves small-buffer optimization
on a 24-byte buffer, without (necessarily) sacrificing trivial relocatability.</p>
   <p><small></small></p>
   <small> <pre class="language-c++ highlight"><c- k>struct</c-> <c- n>short_string</c-> <c- p>{</c->
    <c- b>char</c-> <c- o>*</c-><c- n>data_</c-> <c- o>=</c-> <c- n>buffer_</c-><c- p>;</c->
    <c- b>size_t</c-> <c- n>size_</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c->
    <c- b>char</c-> <c- n>buffer_</c-><c- p>[</c-><c- mi>8</c-><c- p>]</c-> <c- o>=</c-> <c- p>{};</c->

    <c- k>const</c-> <c- b>char</c-> <c- o>*</c-><c- nf>data</c-><c- p>()</c-> <c- k>const</c-> <c- p>{</c-> <c- k>return</c-> <c- n>data_</c-><c- p>;</c-> <c- p>}</c->

    <c- n>short_string</c-><c- p>()</c-> <c- o>=</c-> <c- k>default</c-><c- p>;</c->
    <c- n>short_string</c-><c- p>(</c-><c- k>const</c-> <c- b>char</c-> <c- o>*</c-><c- n>s</c-><c- p>)</c-> <c- o>:</c-> <c- n>size_</c-><c- p>(</c-><c- n>strlen</c-><c- p>(</c-><c- n>s</c-><c- p>))</c-> <c- p>{</c->
        <c- k>if</c-> <c- p>(</c-><c- n>size_</c-> <c- o>&lt;</c-> <c- k>sizeof</c-> <c- n>buffer_</c-><c- p>)</c->
            <c- n>strcpy</c-><c- p>(</c-><c- n>buffer_</c-><c- p>,</c-> <c- n>s</c-><c- p>);</c->
        <c- k>else</c->
            <c- n>data_</c-> <c- o>=</c-> <c- n>strdup</c-><c- p>(</c-><c- n>s</c-><c- p>);</c->
    <c- p>}</c->
    <c- n>short_string</c-><c- p>(</c-><c- n>short_string</c-><c- o>&amp;&amp;</c-> <c- n>s</c-><c- p>)</c-> <c- p>{</c->
        <c- n>memcpy</c-><c- p>(</c-><c- n>this</c-><c- p>,</c-> <c- o>&amp;</c-><c- n>s</c-><c- p>,</c-> <c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>this</c-><c- p>));</c->
        <c- k>if</c-> <c- p>(</c-><c- n>s</c-><c- p>.</c-><c- n>data_</c-> <c- o>==</c-> <c- n>s</c-><c- p>.</c-><c- n>buffer_</c-><c- p>)</c->
            <c- n>data_</c-> <c- o>=</c-> <c- n>buffer_</c-><c- p>;</c->
        <c- k>else</c->
            <c- n>s</c-><c- p>.</c-><c- n>data_</c-> <c- o>=</c-> <c- n>nullptr</c-><c- p>;</c->
    <c- p>}</c->
    <c- o>~</c-><c- n>short_string</c-><c- p>()</c-> <c- p>{</c->
        <c- k>if</c-> <c- p>(</c-><c- n>data_</c-> <c- o>!=</c-> <c- n>buffer_</c-><c- p>)</c->
            <c- n>free</c-><c- p>(</c-><c- n>data_</c-><c- p>);</c->
    <c- p>}</c->
<c- p>};</c->
</pre></small> 
   <h3 class="heading settled" id="non-trivial-sample-list"><span class="content">Allocated memory contains pointer to self</span><a class="self-link" href="#non-trivial-sample-list"></a></h3>
   <p><code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>list</c-></code> needs somewhere to store its "past-the-end" node, commonly referred to
as the "sentinel node," whose <code class="highlight"><c- n>prev</c-></code> pointer points to the list’s last node.
If the sentinel node is allocated on the heap, then <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>list</c-></code> can be trivially
relocatable; but if the sentinel node is placed within the <code class="highlight"><c- n>list</c-></code> object itself
(as happens on libc++ and libstdc++), then relocating the <code class="highlight"><c- n>list</c-></code> object requires
fixing up the list’s last node’s <code class="highlight"><c- n>next</c-></code> pointer so that it points to the
new sentinel node inside the destination <code class="highlight"><c- n>list</c-></code> object. This fixup of an arbitrary
heap object cannot be simulated by <code class="highlight"><c- n>memcpy</c-></code>.</p>
   <p>Traditional implementations of <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>set</c-></code> and <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>map</c-></code> also store a "past-the-end"
node inside themselves and thus also fall into this category.</p>
   <p><small></small></p>
   <small> <pre class="language-c++ highlight"><c- k>struct</c-> <c- n>node</c-> <c- p>{</c->
    <c- n>node</c-> <c- o>*</c-><c- n>prev_</c-> <c- o>=</c-> <c- n>nullptr</c-><c- p>;</c->
    <c- n>node</c-> <c- o>*</c-><c- n>next_</c-> <c- o>=</c-> <c- n>nullptr</c-><c- p>;</c->
<c- p>};</c->
<c- k>struct</c-> <c- n>list</c-> <c- p>{</c->
    <c- n>node</c-> <c- n>n_</c-><c- p>;</c->
    <c- n>iterator</c-> <c- nf>begin</c-><c- p>()</c-> <c- p>{</c-> <c- k>return</c-> <c- n>iterator</c-><c- p>(</c-><c- n>n_</c-><c- p>.</c-><c- n>next_</c-><c- p>);</c-> <c- p>}</c->
    <c- n>iterator</c-> <c- nf>end</c-><c- p>()</c-> <c- p>{</c-> <c- k>return</c-> <c- n>iterator</c-><c- p>(</c-><c- o>&amp;</c-><c- n>n_</c-><c- p>);</c-> <c- p>}</c->
    <c- n>list</c-><c- p>(</c-><c- n>list</c-><c- o>&amp;&amp;</c-> <c- n>l</c-><c- p>)</c-> <c- p>{</c->
        <c- k>if</c-> <c- p>(</c-><c- n>l</c-><c- p>.</c-><c- n>n_</c-><c- p>.</c-><c- n>next_</c-><c- p>)</c-> <c- n>l</c-><c- p>.</c-><c- n>n_</c-><c- p>.</c-><c- n>next_</c-><c- o>-></c-><c- n>prev_</c-> <c- o>=</c-> <c- o>&amp;</c-><c- n>n_</c-><c- p>;</c->  <c- c1>// fixup</c->
        <c- k>if</c-> <c- p>(</c-><c- n>l</c-><c- p>.</c-><c- n>n_</c-><c- p>.</c-><c- n>prev_</c-><c- p>)</c-> <c- n>l</c-><c- p>.</c-><c- n>n_</c-><c- p>.</c-><c- n>prev_</c-><c- o>-></c-><c- n>next_</c-> <c- o>=</c-> <c- o>&amp;</c-><c- n>n_</c-><c- p>;</c->  <c- c1>// fixup</c->
        <c- n>n_</c-> <c- o>=</c-> <c- n>l</c-><c- p>.</c-><c- n>n_</c-><c- p>;</c->
        <c- n>l</c-><c- p>.</c-><c- n>n_</c-> <c- o>=</c-> <c- n>node</c-><c- p>{};</c->
    <c- p>}</c->
    <c- c1>// ...</c->
<c- p>};</c->
</pre></small> 
   <h3 class="heading settled" id="non-trivial-sample-offset-ptr"><span class="content">Class invariant depends on <code class="highlight"><c- k>this</c-></code></span><a class="self-link" href="#non-trivial-sample-offset-ptr"></a></h3>
   <p>The <code class="highlight"><c- n>offset_ptr</c-></code> provided by <a data-link-type="biblio" href="#biblio-boostinterprocess">[Boost.Interprocess]</a> is an example of this category.</p>
   <p><small></small></p>
   <small> <pre class="language-c++ highlight"><c- k>struct</c-> <c- n>offset_ptr</c-> <c- p>{</c->
    <c- b>uintptr_t</c-> <c- n>value_</c-><c- p>;</c->

    <c- b>uintptr_t</c-> <c- nf>here</c-><c- p>()</c-> <c- k>const</c-> <c- p>{</c-> <c- k>return</c-> <c- b>uintptr_t</c-><c- p>(</c-><c- n>this</c-><c- p>);</c-> <c- p>}</c->
    <c- b>uintptr_t</c-> <c- nf>distance_to</c-><c- p>(</c-><c- b>void</c-> <c- o>*</c-><c- n>p</c-><c- p>)</c-> <c- k>const</c-> <c- p>{</c-> <c- k>return</c-> <c- b>uintptr_t</c-><c- p>(</c-><c- n>p</c-><c- p>)</c-> <c- o>-</c-> <c- n>here</c-><c- p>();</c-> <c- p>}</c->
    <c- b>void</c-> <c- o>*</c-><c- nf>get</c-><c- p>()</c-> <c- k>const</c-> <c- p>{</c-> <c- k>return</c-> <c- p>(</c-><c- b>void</c-><c- o>*</c-><c- p>)(</c-><c- n>here</c-><c- p>()</c-> <c- o>+</c-> <c- n>value_</c-><c- p>);</c-> <c- p>}</c->

    <c- n>offset_ptr</c-><c- p>()</c-> <c- o>:</c-> <c- n>value_</c-><c- p>(</c-><c- n>distance_to</c-><c- p>(</c-><c- n>nullptr</c-><c- p>))</c-> <c- p>{}</c->
    <c- n>offset_ptr</c-><c- p>(</c-><c- b>void</c-> <c- o>*</c-><c- n>p</c-><c- p>)</c-> <c- o>:</c-> <c- n>value_</c-><c- p>(</c-><c- n>distance_to</c-><c- p>(</c-><c- n>p</c-><c- p>))</c-> <c- p>{}</c->
    <c- n>offset_ptr</c-><c- p>(</c-><c- k>const</c-> <c- n>offset_ptr</c-><c- o>&amp;</c-> <c- n>rhs</c-><c- p>)</c-> <c- o>:</c-> <c- n>value_</c-><c- p>(</c-><c- n>distance_to</c-><c- p>(</c-><c- n>rhs</c-><c- p>.</c-><c- n>get</c-><c- p>()))</c-> <c- p>{}</c->
    <c- n>offset_ptr</c-><c- o>&amp;</c-> <c- n>operator</c-><c- o>=</c-><c- p>(</c-><c- k>const</c-> <c- n>offset_ptr</c-><c- o>&amp;</c-> <c- n>rhs</c-><c- p>)</c-> <c- p>{</c->
        <c- n>value_</c-> <c- o>=</c-> <c- n>distance_to</c-><c- p>(</c-><c- n>rhs</c-><c- p>.</c-><c- n>get</c-><c- p>());</c->
        <c- k>return</c-> <c- o>*</c-><c- n>this</c-><c- p>;</c->
    <c- p>}</c->
    <c- o>~</c-><c- n>offset_ptr</c-><c- p>()</c-> <c- o>=</c-> <c- k>default</c-><c- p>;</c->
<c- p>};</c->
</pre></small> 
   <h3 class="heading settled" id="non-trivial-sample-registry"><span class="content">Program invariant depends on <code class="highlight"><c- k>this</c-></code></span><a class="self-link" href="#non-trivial-sample-registry"></a></h3>
   <p>In the following snippet, <code class="highlight"><c- k>struct</c-> <c- n>Widget</c-></code> is relocatable, but not
trivially relocatable, because the relocation operation of destroying a <code class="highlight"><c- n>Widget</c-></code> at point A
and constructing a new <code class="highlight"><c- n>Widget</c-></code> at point B has behavior that is observably different
from a simple <code class="highlight"><c- n>memcpy</c-></code>.</p>
   <p><small></small></p>
   <small> <pre class="language-c++ highlight"><c- n>std</c-><c- o>::</c-><c- n>set</c-><c- o>&lt;</c-><c- b>void</c-> <c- o>*></c-> <c- n>registry</c-><c- p>;</c->

<c- k>struct</c-> <c- n>registered_object</c-> <c- p>{</c->
    <c- n>registered_object</c-><c- p>()</c-> <c- p>{</c-> <c- n>registry</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>this</c-><c- p>);</c-> <c- p>}</c->
    <c- n>registered_object</c-><c- p>(</c-><c- n>registered_object</c-><c- o>&amp;&amp;</c-><c- p>)</c-> <c- o>=</c-> <c- k>default</c-><c- p>;</c->
    <c- n>registered_object</c-><c- p>(</c-><c- k>const</c-> <c- n>registered_object</c-><c- o>&amp;</c-><c- p>)</c-> <c- o>=</c-> <c- k>default</c-><c- p>;</c->
    <c- n>registered_object</c-><c- o>&amp;</c-> <c- n>operator</c-><c- o>=</c-><c- p>(</c-><c- n>registered_object</c-><c- o>&amp;&amp;</c-><c- p>)</c-> <c- o>=</c-> <c- k>default</c-><c- p>;</c->
    <c- n>registered_object</c-><c- o>&amp;</c-> <c- n>operator</c-><c- o>=</c-><c- p>(</c-><c- k>const</c-> <c- n>registered_object</c-><c- o>&amp;</c-><c- p>)</c-> <c- o>=</c-> <c- k>default</c-><c- p>;</c->
    <c- o>~</c-><c- n>registered_object</c-><c- p>()</c-> <c- p>{</c-> <c- n>registry</c-><c- p>.</c-><c- n>erase</c-><c- p>(</c-><c- n>this</c-><c- p>);</c-> <c- p>}</c->
<c- p>};</c->

<c- k>struct</c-> <c- nl>Widget</c-> <c- p>:</c-> <c- n>registered_object</c-> <c- p>{};</c->
</pre></small> 
   <h2 class="heading settled" id="implementation"><span class="content">Appendix D: Implementation and benchmarks</span><a class="self-link" href="#implementation"></a></h2>
   <p>A prototype Clang/libc++ implementation is at</p>
   <ul>
    <li data-md>
     <p><a href="https://github.com/Quuxplusone/clang/tree/trivially-relocatable">github.com/Quuxplusone/clang/tree/trivially-relocatable</a></p>
    <li data-md>
     <p><a href="https://github.com/Quuxplusone/libcxx/tree/trivially-relocatable">github.com/Quuxplusone/libcxx/tree/trivially-relocatable</a></p>
    <li data-md>
     <p><a href="https://p1144.godbolt.org/z/oWEd_X">godbolt.org</a>, under the name "x86-64 clang (experimental P1144)"</p>
   </ul>
   <p>As observed in <a data-link-type="biblio" href="#biblio-cppchat">[CppChat]</a> (@21:55), since the essence of this feature is to eliminate calls
to user-defined functions, in principle you could make a benchmark to show any arbitrarily
large amount of speedup. <a data-link-type="biblio" href="#biblio-bench">[Bench]</a> shows a 3x speedup for <code class="highlight"><c- n>vector</c-><c- o>&lt;</c-><c- n>unique_ptr</c-><c- o>&lt;</c-><c- b>int</c-><c- o>>>::</c-><c- n>reserve</c-></code>.</p>
  </main>
<script>
(function() {
  "use strict";
  var collapseSidebarText = '<span aria-hidden="true">←</span> '
                          + '<span>Collapse Sidebar</span>';
  var expandSidebarText   = '<span aria-hidden="true">→</span> '
                          + '<span>Pop Out Sidebar</span>';
  var tocJumpText         = '<span aria-hidden="true">↑</span> '
                          + '<span>Jump to Table of Contents</span>';

  var sidebarMedia = window.matchMedia('screen and (min-width: 78em)');
  var autoToggle   = function(e){ toggleSidebar(e.matches) };
  if(sidebarMedia.addListener) {
    sidebarMedia.addListener(autoToggle);
  }

  function toggleSidebar(on) {
    if (on == undefined) {
      on = !document.body.classList.contains('toc-sidebar');
    }

    /* Don’t scroll to compensate for the ToC if we’re above it already. */
    var headY = 0;
    var head = document.querySelector('.head');
    if (head) {
      // terrible approx of "top of ToC"
      headY += head.offsetTop + head.offsetHeight;
    }
    var skipScroll = window.scrollY < headY;

    var toggle = document.getElementById('toc-toggle');
    var tocNav = document.getElementById('toc');
    if (on) {
      var tocHeight = tocNav.offsetHeight;
      document.body.classList.add('toc-sidebar');
      document.body.classList.remove('toc-inline');
      toggle.innerHTML = collapseSidebarText;
      if (!skipScroll) {
        window.scrollBy(0, 0 - tocHeight);
      }
      tocNav.focus();
      sidebarMedia.addListener(autoToggle); // auto-collapse when out of room
    }
    else {
      document.body.classList.add('toc-inline');
      document.body.classList.remove('toc-sidebar');
      toggle.innerHTML = expandSidebarText;
      if (!skipScroll) {
        window.scrollBy(0, tocNav.offsetHeight);
      }
      if (toggle.matches(':hover')) {
        /* Unfocus button when not using keyboard navigation,
           because I don’t know where else to send the focus. */
        toggle.blur();
      }
    }
  }

  function createSidebarToggle() {
    /* Create the sidebar toggle in JS; it shouldn’t exist when JS is off. */
    var toggle = document.createElement('a');
      /* This should probably be a button, but appearance isn’t standards-track.*/
    toggle.id = 'toc-toggle';
    toggle.class = 'toc-toggle';
    toggle.href = '#toc';
    toggle.innerHTML = collapseSidebarText;

    sidebarMedia.addListener(autoToggle);
    var toggler = function(e) {
      e.preventDefault();
      sidebarMedia.removeListener(autoToggle); // persist explicit off states
      toggleSidebar();
      return false;
    }
    toggle.addEventListener('click', toggler, false);


    /* Get <nav id=toc-nav>, or make it if we don’t have one. */
    var tocNav = document.getElementById('toc-nav');
    if (!tocNav) {
      tocNav = document.createElement('p');
      tocNav.id = 'toc-nav';
      /* Prepend for better keyboard navigation */
      document.body.insertBefore(tocNav, document.body.firstChild);
    }
    /* While we’re at it, make sure we have a Jump to Toc link. */
    var tocJump = document.getElementById('toc-jump');
    if (!tocJump) {
      tocJump = document.createElement('a');
      tocJump.id = 'toc-jump';
      tocJump.href = '#toc';
      tocJump.innerHTML = tocJumpText;
      tocNav.appendChild(tocJump);
    }

    tocNav.appendChild(toggle);
  }

  var toc = document.getElementById('toc');
  if (toc) {
    createSidebarToggle();
    toggleSidebar(sidebarMedia.matches);

    /* If the sidebar has been manually opened and is currently overlaying the text
       (window too small for the MQ to add the margin to body),
       then auto-close the sidebar once you click on something in there. */
    toc.addEventListener('click', function(e) {
      if(e.target.tagName.toLowerCase() == "a" && document.body.classList.contains('toc-sidebar') && !sidebarMedia.matches) {
        toggleSidebar(false);
      }
    }, false);
  }
  else {
    console.warn("Can’t find Table of Contents. Please use <nav id='toc'> around the ToC.");
  }

  /* Wrap tables in case they overflow */
  var tables = document.querySelectorAll(':not(.overlarge) > table.data, :not(.overlarge) > table.index');
  var numTables = tables.length;
  for (var i = 0; i < numTables; i++) {
    var table = tables[i];
    var wrapper = document.createElement('div');
    wrapper.className = 'overlarge';
    table.parentNode.insertBefore(wrapper, table);
    wrapper.appendChild(table);
  }

})();
</script>
  <h2 class="no-num no-ref heading settled" id="index"><span class="content">Index</span><a class="self-link" href="#index"></a></h2>
  <h3 class="no-num no-ref heading settled" id="index-defined-here"><span class="content">Terms defined by this specification</span><a class="self-link" href="#index-defined-here"></a></h3>
  <ul class="index">
   <li><a href="#abstract-opdef-relocation-operation">relocation operation</a><span>, in §4.1</span>
   <li><a href="#abstract-opdef-trivially-relocatable">trivially relocatable</a><span>, in §4.4</span>
  </ul>
  <h2 class="no-num no-ref heading settled" id="references"><span class="content">References</span><a class="self-link" href="#references"></a></h2>
  <h3 class="no-num no-ref heading settled" id="normative"><span class="content">Normative References</span><a class="self-link" href="#normative"></a></h3>
  <dl>
   <dt id="biblio-n4750">[N4750]
   <dd>ISO/IEC JTC1/SC22/WG21 - The C++ Standards Committee; Richard Smith. <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4750.pdf">N4750: Working Draft, Standard for Programming Language C++</a>. May 2018. URL: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4750.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4750.pdf</a>
  </dl>
  <h3 class="no-num no-ref heading settled" id="informative"><span class="content">Informative References</span><a class="self-link" href="#informative"></a></h3>
  <dl>
   <dt id="biblio-announcing">[Announcing]
   <dd>Arthur O'Dwyer. <a href="https://quuxplusone.github.io/blog/2018/07/18/announcing-trivially-relocatable/">Announcing "trivially relocatable"</a>. July 2018. URL: <a href="https://quuxplusone.github.io/blog/2018/07/18/announcing-trivially-relocatable/">https://quuxplusone.github.io/blog/2018/07/18/announcing-trivially-relocatable/</a>
   <dt id="biblio-bench">[Bench]
   <dd>Arthur O'Dwyer. <a href="https://github.com/Quuxplusone/from-scratch/blob/095b246d/cppnow2018/benchmark-relocatable.cc">Benchmark code from "The Best Type Traits C++ Doesn't Have"</a>. April 2018. URL: <a href="https://github.com/Quuxplusone/from-scratch/blob/095b246d/cppnow2018/benchmark-relocatable.cc">https://github.com/Quuxplusone/from-scratch/blob/095b246d/cppnow2018/benchmark-relocatable.cc</a>
   <dt id="biblio-best">[Best]
   <dd>Arthur O'Dwyer. <a href="https://www.youtube.com/watch?v=MWBfmmg8-Yo">The Best Type Traits C++ Doesn't Have (video)</a>. April 2018. URL: <a href="https://www.youtube.com/watch?v=MWBfmmg8-Yo">https://www.youtube.com/watch?v=MWBfmmg8-Yo</a>
   <dt id="biblio-boostinterprocess">[Boost.Interprocess]
   <dd>Ion Gaztañaga. <a href="https://www.boost.org/doc/libs/1_67_0/doc/html/interprocess/offset_ptr.html">Mapping Address Independent Pointer: offset_ptr</a>. 2005. URL: <a href="https://www.boost.org/doc/libs/1_67_0/doc/html/interprocess/offset_ptr.html">https://www.boost.org/doc/libs/1_67_0/doc/html/interprocess/offset_ptr.html</a>
   <dt id="biblio-contra">[Contra]
   <dd>Arthur O'Dwyer. <a href="https://quuxplusone.github.io/blog/2018/04/15/built-in-library-types/">Contra built-in library types</a>. April 2018. URL: <a href="https://quuxplusone.github.io/blog/2018/04/15/built-in-library-types/">https://quuxplusone.github.io/blog/2018/04/15/built-in-library-types/</a>
   <dt id="biblio-cppchat">[CppChat]
   <dd>Howard Hinnant; Arthur O'Dwyer. <a href="https://www.youtube.com/watch?v=8u5Qi4FgTP8">cpp.chat episode 40: It works but it's undefined behavior</a>. August 2018. URL: <a href="https://www.youtube.com/watch?v=8u5Qi4FgTP8">https://www.youtube.com/watch?v=8u5Qi4FgTP8</a>
   <dt id="biblio-eastl">[EASTL]
   <dd>Paul Pedriana. <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2271.html#type_traits_extensions">N2271: EASTL — Electronic Arts Standard Template Library</a>. URL: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2271.html#type_traits_extensions">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2271.html#type_traits_extensions</a>
   <dt id="biblio-folly">[Folly]
   <dd>Facebook. <a href="https://github.com/facebook/folly/blob/master/folly/docs/FBVector.md#object-relocation">Folly documentation on "Object Relocation"</a>. URL: <a href="https://github.com/facebook/folly/blob/master/folly/docs/FBVector.md#object-relocation">https://github.com/facebook/folly/blob/master/folly/docs/FBVector.md#object-relocation</a>
   <dt id="biblio-follyissue889">[FollyIssue889]
   <dd>Arthur O'Dwyer. <a href="https://github.com/facebook/folly/issues/889">Traits.h marks std::list as trivially relocatable, but in fact it is not</a>. URL: <a href="https://github.com/facebook/folly/issues/889">https://github.com/facebook/folly/issues/889</a>
   <dt id="biblio-libcxxany">[LibcxxAny]
   <dd>Eric Fiselier. <a href="https://github.com/llvm-mirror/libcxx/blob/8fdc4918/include/any#L389-L394">libc++ implementation of std::any (trivially relocatable)</a>. July 2016. URL: <a href="https://github.com/llvm-mirror/libcxx/blob/8fdc4918/include/any#L389-L394">https://github.com/llvm-mirror/libcxx/blob/8fdc4918/include/any#L389-L394</a>
   <dt id="biblio-libcxxfunction">[LibcxxFunction]
   <dd>Howard Hinnant et al. <a href="https://github.com/llvm-mirror/libcxx/blob/4e7ffcaa/include/functional#L1719-L1734">libc++ implementation of std::function (non-trivially relocatable)</a>. URL: <a href="https://github.com/llvm-mirror/libcxx/blob/4e7ffcaa/include/functional#L1719-L1734">https://github.com/llvm-mirror/libcxx/blob/4e7ffcaa/include/functional#L1719-L1734</a>
   <dt id="biblio-libstdcxxfunction">[LibstdcxxFunction]
   <dd>Doug Gregor et al. <a href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/std_function.h">libstdc++ implementation of std::function (trivially relocatable)</a>. URL: <a href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/std_function.h">https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/std_function.h</a>
   <dt id="biblio-lwg2139">[LWG2139]
   <dd>Loïc Joly. <a href="https://cplusplus.github.io/LWG/issue2139">What is a user-defined type?</a>. March 2012–June 2018. URL: <a href="https://cplusplus.github.io/LWG/issue2139">https://cplusplus.github.io/LWG/issue2139</a>
   <dt id="biblio-lwg3119">[LWG3119]
   <dd>Hubert Tong. <a href="https://cplusplus.github.io/LWG/issue3119">Program-definedness of closure types</a>. June 2018—. URL: <a href="https://cplusplus.github.io/LWG/issue3119">https://cplusplus.github.io/LWG/issue3119</a>
   <dt id="biblio-n1377">[N1377]
   <dd>Howard Hinnant; Peter Dimov; Dave Abrahams. <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm">N1377: A Proposal to Add Move Semantics Support to the C++ Language</a>. September 2002. URL: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm</a>
   <dt id="biblio-n2754">[N2754]
   <dd>Rodrigo Castro Campos. <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2754.html">N2754: TriviallyDestructibleAfterMove and TriviallyReallocatable (rev 3)</a>. September 2008. URL: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2754.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2754.html</a>
   <dt id="biblio-n4158">[N4158]
   <dd>Pablo Halpern. <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4158.pdf">N4158: Destructive Move (rev 1)</a>. October 2014. URL: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4158.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4158.pdf</a>
   <dt id="biblio-p0023r0">[P0023R0]
   <dd>Denis Bider. <a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0023r0.pdf">P0023R0: Relocator: Efficiently Moving Objects</a>. April 2016. URL: <a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0023r0.pdf">http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0023r0.pdf</a>
   <dt id="biblio-p1029r0">[P1029R0]
   <dd>Niall Douglas. <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1029r0.pdf">P1029R0: SG14 [[move_relocates]]</a>. May 2018. URL: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1029r0.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1029r0.pdf</a>
   <dt id="biblio-p1152r0">[P1152R0]
   <dd>JF Bastien. <a href="http://wg21.link/p1152r0">P1152R0: Deprecating volatile</a>. July 2018. URL: <a href="http://wg21.link/p1152r0">http://wg21.link/p1152r0</a>
   <dt id="biblio-p1153r0">[P1153R0]
   <dd>Arthur O'Dwyer; JF Bastien. <a href="http://wg21.link/p1153r0">P1153R0: Copying volatile subobjects is not trivial</a>. July 2018. URL: <a href="http://wg21.link/p1153r0">http://wg21.link/p1153r0</a>
   <dt id="biblio-sane">[Sane]
   <dd>Arthur O'Dwyer. <a href="https://quuxplusone.github.io/blog/2018/07/06/thoughts-on-sanely-move-assignable/">Thoughts on "sanely move-assignable"</a>. July 2018. URL: <a href="https://quuxplusone.github.io/blog/2018/07/06/thoughts-on-sanely-move-assignable/">https://quuxplusone.github.io/blog/2018/07/06/thoughts-on-sanely-move-assignable/</a>
   <dt id="biblio-subobjects">[Subobjects]
   <dd>Arthur O'Dwyer. <a href="https://quuxplusone.github.io/blog/2018/07/13/trivially-copyable-corner-cases/">When is a trivially copyable object not trivially copyable?</a>. July 2018. URL: <a href="https://quuxplusone.github.io/blog/2018/07/13/trivially-copyable-corner-cases/">https://quuxplusone.github.io/blog/2018/07/13/trivially-copyable-corner-cases/</a>
   <dt id="biblio-swift">[Swift]
   <dd>Michael Ilseman. <a href="https://github.com/apple/swift/blob/master/docs/ABIStabilityManifesto.md">Swift ABI Stability Manifesto</a>. January 2017. URL: <a href="https://github.com/apple/swift/blob/master/docs/ABIStabilityManifesto.md">https://github.com/apple/swift/blob/master/docs/ABIStabilityManifesto.md</a>
   <dt id="biblio-tcf">[TCF]
   <dd>Arthur O'Dwyer. <a href="https://quuxplusone.github.io/blog/2018/07/03/trivially-constructible-from/">Trivially-constructible-from</a>. July 2018. URL: <a href="https://quuxplusone.github.io/blog/2018/07/03/trivially-constructible-from/">https://quuxplusone.github.io/blog/2018/07/03/trivially-constructible-from/</a>
   <dt id="biblio-wang">[Wang]
   <dd>Mingxin Wang. <a href="https://groups.google.com/a/isocpp.org/d/msg/std-proposals/HGCHVSRwSMk/k7Ir-rmxBgAJ">Better Performance in Polymorphic Programming: Trivially Swappable</a>. June 2018. URL: <a href="https://groups.google.com/a/isocpp.org/d/msg/std-proposals/HGCHVSRwSMk/k7Ir-rmxBgAJ">https://groups.google.com/a/isocpp.org/d/msg/std-proposals/HGCHVSRwSMk/k7Ir-rmxBgAJ</a>
  </dl>
  <h2 class="no-num no-ref heading settled" id="issues-index"><span class="content">Issues Index</span><a class="self-link" href="#issues-index"></a></h2>
  <div style="counter-reset:issue">
   <div class="issue"> [definitions] is probably the wrong place for the core-language definition of "relocation operation"<a href="#issue-75ffe201"> ↵ </a></div>
   <div class="issue"> this definition of "relocation operation" is not good<a href="#issue-7c86f5f7"> ↵ </a></div>
   <div class="issue"> The relevant move constructor, copy constructor, and/or destructor must be public and unambiguous.
We imply this via the words "A move-constructible, destructible object type". However, "move-constructible"
and "destructible" are library concepts, not core language concepts, so maybe it is inappropriate
to use them here.<a href="#issue-f1c9711d"> ↵ </a></div>
   <div class="issue">
     Consider the following test cases—<wbr><small> <pre class="language-c++ highlight">    <c- k>struct</c-> <c- n>A</c-> <c- p>{</c->
        <c- k>struct</c-> <c- n>MA</c-> <c- p>{</c->
            <c- n>MA</c-><c- p>(</c-><c- n>MA</c-><c- o>&amp;</c-><c- p>);</c->
            <c- n>MA</c-><c- p>(</c-><c- k>const</c-> <c- n>MA</c-><c- o>&amp;</c-><c- p>)</c-> <c- o>=</c-> <c- k>default</c-><c- p>;</c->
            <c- n>MA</c-><c- p>(</c-><c- n>MA</c-><c- o>&amp;&amp;</c-><c- p>)</c-> <c- o>=</c-> <c- k>default</c-><c- p>;</c->
        <c- p>};</c->
        <c- n>mutable</c-> <c- n>MA</c-> <c- n>ma</c-><c- p>;</c->
        <c- n>A</c-><c- p>(</c-><c- k>const</c-> <c- n>A</c-><c- o>&amp;</c-><c- p>)</c-> <c- o>=</c-> <c- k>default</c-><c- p>;</c->
    <c- p>};</c->
    <c- n>static_assert</c-><c- p>(</c-><c- n>not</c-> <c- n>std</c-><c- o>::</c-><c- n>is_trivially_relocatable_v</c-><c- o>&lt;</c-><c- n>A</c-><c- o>></c-><c- p>);</c->

    <c- k>struct</c-> <c- n>B</c-> <c- p>{</c->
        <c- k>struct</c-> <c- n>MB</c-> <c- p>{</c->
            <c- n>MB</c-><c- p>(</c-><c- k>const</c-> <c- k>volatile</c-> <c- n>MB</c-><c- o>&amp;</c-><c- p>);</c->
            <c- n>MB</c-><c- p>(</c-><c- k>const</c-> <c- n>MB</c-><c- o>&amp;</c-><c- p>)</c-> <c- o>=</c-> <c- k>default</c-><c- p>;</c->
            <c- n>MB</c-><c- p>(</c-><c- n>MB</c-><c- o>&amp;&amp;</c-><c- p>)</c-> <c- o>=</c-> <c- k>default</c-><c- p>;</c->
        <c- p>};</c->
        <c- k>volatile</c-> <c- n>MB</c-> <c- n>mb</c-><c- p>;</c->
        <c- n>B</c-><c- p>(</c-><c- k>const</c-> <c- n>B</c-><c- o>&amp;</c-><c- p>)</c-> <c- o>=</c-> <c- k>default</c-><c- p>;</c->
    <c- p>};</c->
    <c- n>static_assert</c-><c- p>(</c-><c- n>not</c-> <c- n>std</c-><c- o>::</c-><c- n>is_trivially_relocatable_v</c-><c- o>&lt;</c-><c- n>B</c-><c- o>></c-><c- p>);</c->

    <c- k>struct</c-> <c- p>[[</c-><c- n>trivially_relocatable</c-><c- p>]]</c-> <c- n>I</c-> <c- p>{</c->
        <c- n>I</c-><c- p>(</c-><c- n>I</c-><c- o>&amp;&amp;</c-><c- p>);</c->
    <c- p>};</c->
    <c- k>struct</c-> <c- nl>J</c-> <c- p>:</c-> <c- n>I</c-> <c- p>{</c->
        <c- n>J</c-><c- p>(</c-><c- k>const</c-> <c- n>J</c-><c- o>&amp;</c-><c- p>);</c->
        <c- n>J</c-><c- p>(</c-><c- n>J</c-><c- o>&amp;&amp;</c-><c- p>)</c-> <c- o>=</c-> <c- k>default</c-><c- p>;</c->
    <c- p>};</c->
    <c- n>static_assert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>is_trivially_relocatable_v</c-><c- o>&lt;</c-><c- n>J</c-><c- o>></c-><c- p>);</c->
</pre></small> We <em>must</em> find a rule that makes neither <code class="highlight"><c- n>A</c-></code> nor <code class="highlight"><c- n>B</c-></code> trivially relocatable,
because the move-construction <code class="highlight"><c- n>A</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>a</c-><c- p>))</c-></code> invokes user-provided copy constructor <code class="highlight"><c- n>MA</c-><c- p>(</c-><c- n>MA</c-><c- o>&amp;</c-><c- p>)</c-></code> and the move-construction <code class="highlight"><c- n>B</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>b</c-><c- p>))</c-></code> invokes user-provided copy constructor <code class="highlight"><c- n>MB</c-><c- p>(</c-><c- k>const</c-> <c- k>volatile</c-> <c- n>MB</c-><c- o>&amp;</c-><c- p>)</c-></code>. 
    <p>We would <em>like</em> to find a rule that makes <code class="highlight"><c- n>J</c-></code> trivially relocatable,
because the <code class="highlight"><c- nl>J</c-> <c- p>:</c-> <c- n>I</c-></code> pattern is used to implement "conditionally trivial relocatability"
for all allocator-aware containers in my libc++ reference implementation.
(The move-constructor and destructor of <code class="highlight"><c- n>J</c-></code> are moved into a base class template <code class="highlight"><c- n>I</c-></code> which is conditionally marked with <code class="highlight"><c- p>[[</c-><c- n>trivially_relocatable</c-><c- p>]]</c-></code>. The copy constructor,
assignment operators, etc. are not moved into the base class because they are not
expected to interfere with trivial relocatability.)
If the <code class="highlight"><c- p>[[</c-><c- n>trivially_relocatable</c-><c- p>]]</c-></code> attribute were modified to take a boolean parameter,
we might not care about this <code class="highlight"><c- n>J</c-></code> example.</p>
     <a href="#issue-b03b0df9"> ↵ </a>
   </div>
   <div class="issue"> "If a type <code class="highlight"><c- n>T</c-></code> is declared with the <code class="highlight"><c- n>trivially_relocatable</c-></code> attribute, and <code class="highlight"><c- n>T</c-></code> is either not move-constructible
or not destructible, the program is ill-formed." We might want to replace this wording with
a mere "Note" <em>encouraging</em> implementations to diagnose.
See <a href="https://p1144.godbolt.org/z/ociAVX">this example</a> where a diagnostic might be unwanted.<a href="#issue-20b76dab"> ↵ </a></div>
  </div>
  <aside class="dfn-panel" data-for="abstract-opdef-relocation-operation">
   <b><a href="#abstract-opdef-relocation-operation">#abstract-opdef-relocation-operation</a></b><b>Referenced in:</b>
   <ul>
    <li><a href="#ref-for-abstract-opdef-relocation-operation">4.4. Trivially relocatable type</a>
   </ul>
  </aside>
  <aside class="dfn-panel" data-for="abstract-opdef-trivially-relocatable">
   <b><a href="#abstract-opdef-trivially-relocatable">#abstract-opdef-trivially-relocatable</a></b><b>Referenced in:</b>
   <ul>
    <li><a href="#ref-for-abstract-opdef-trivially-relocatable">1. Introduction and motivation</a>
    <li><a href="#ref-for-abstract-opdef-trivially-relocatable①">4.6. Type traits is_relocatable etc.</a>
   </ul>
  </aside>
<script>/* script-dfn-panel */

document.body.addEventListener("click", function(e) {
    var queryAll = function(sel) { return [].slice.call(document.querySelectorAll(sel)); }
    // Find the dfn element or panel, if any, that was clicked on.
    var el = e.target;
    var target;
    var hitALink = false;
    while(el.parentElement) {
        if(el.tagName == "A") {
            // Clicking on a link in a <dfn> shouldn't summon the panel
            hitALink = true;
        }
        if(el.classList.contains("dfn-paneled")) {
            target = "dfn";
            break;
        }
        if(el.classList.contains("dfn-panel")) {
            target = "dfn-panel";
            break;
        }
        el = el.parentElement;
    }
    if(target != "dfn-panel") {
        // Turn off any currently "on" or "activated" panels.
        queryAll(".dfn-panel.on, .dfn-panel.activated").forEach(function(el){
            el.classList.remove("on");
            el.classList.remove("activated");
        });
    }
    if(target == "dfn" && !hitALink) {
        // open the panel
        var dfnPanel = document.querySelector(".dfn-panel[data-for='" + el.id + "']");
        if(dfnPanel) {
            dfnPanel.classList.add("on");
            var rect = el.getBoundingClientRect();
            dfnPanel.style.left = window.scrollX + rect.right + 5 + "px";
            dfnPanel.style.top = window.scrollY + rect.top + "px";
            var panelRect = dfnPanel.getBoundingClientRect();
            var panelWidth = panelRect.right - panelRect.left;
            if(panelRect.right > document.body.scrollWidth && (rect.left - (panelWidth + 5)) > 0) {
                // Reposition, because the panel is overflowing
                dfnPanel.style.left = window.scrollX + rect.left - (panelWidth + 5) + "px";
            }
        } else {
            console.log("Couldn't find .dfn-panel[data-for='" + el.id + "']");
        }
    } else if(target == "dfn-panel") {
        // Switch it to "activated" state, which pins it.
        el.classList.add("activated");
        el.style.left = null;
        el.style.top = null;
    }

});
</script>